<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pong - Pro Multiplayer</title>
    <style>
        /* --- CORE STYLES --- */
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; user-select: none; -webkit-tap-highlight-color: transparent; }
        
        body {
            background-color: #050505;
            height: 100vh; width: 100vw;
            overflow: hidden; 
            display: flex; justify-content: center; align-items: center;
            font-family: "Segoe UI", sans-serif;
        }

        /* GAME CONTAINER */
        #game-layer {
            position: relative;
            box-shadow: 0 0 40px rgba(0, 243, 255, 0.1);
            border: 2px solid #222;
        }
        canvas { display: block; width: 100%; height: 100%; }

        /* TOUCH ZONES (Invisible layers for better control) */
        .touch-zone {
            position: absolute; top: 0; bottom: 0; width: 50%;
            z-index: 10;
            /* background: rgba(255,0,0,0.1); Debugging Color */ 
        }
        #leftZone { left: 0; }
        #rightZone { right: 0; }

        /* UI OVERLAY */
        .ui-layer { position: absolute; inset: 0; pointer-events: none; z-index: 20; }
        .interactive { pointer-events: auto; }
        
        .hud { 
            position: absolute; top: 20px; width: 100%; 
            display: flex; justify-content: center; gap: 40px;
        }
        .score { 
            color: white; font-size: 40px; font-weight: 900; 
            text-shadow: 0 4px 10px rgba(0,0,0,0.8); opacity: 0.8;
        }

        /* SCREENS & MENUS */
        .screen {
            position: absolute; inset: 0; background: rgba(5,5,5,0.95);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.3s;
        }
        .hidden { opacity: 0; pointer-events: none; }
        
        h1 { color: #fff; font-size: 40px; letter-spacing: 5px; margin-bottom: 30px; text-transform: uppercase; }
        
        button {
            background: #111; border: 1px solid #444; color: #ccc;
            padding: 15px 30px; margin: 10px; font-size: 16px; font-weight: bold;
            text-transform: uppercase; cursor: pointer; min-width: 200px;
            transition: all 0.2s;
        }
        button:active { background: #333; transform: scale(0.96); }
        .btn-blue { border-color: #00f3ff; color: #00f3ff; }
        .btn-green { border-color: #0f0; color: #0f0; }

        .input-code {
            background: #000; border: 2px solid #333; color: #fff;
            padding: 15px; font-size: 24px; text-align: center; letter-spacing: 5px;
            width: 180px; margin-bottom: 20px; outline: none;
        }
        
        /* NOTIFICATIONS */
        #toast {
            position: absolute; bottom: 30px; background: #333; color: white;
            padding: 10px 20px; border-radius: 20px; font-size: 12px;
            opacity: 0; transition: opacity 0.5s;
        }
    </style>
</head>
<body>

    <div id="game-layer">
        <div id="leftZone" class="touch-zone interactive"></div>
        <div id="rightZone" class="touch-zone interactive"></div>

        <div class="ui-layer">
            <div class="hud">
                <div class="score" style="color:#ff0055" id="scoreL">0</div>
                <div class="score" style="color:#00f3ff" id="scoreR">0</div>
            </div>
            
            <div id="toast">Notification</div>

            <div id="menuScreen" class="screen interactive">
                <h1>ARCADE PONG</h1>
                <button class="btn-blue" id="btnAI">Single Player</button>
                <button class="btn-green" id="btnOnline">Multiplayer</button>
            </div>

            <div id="lobbyScreen" class="screen hidden interactive">
                <h1>LOBBY</h1>
                <div id="lobbyMain" style="text-align:center">
                    <button id="btnHost" class="btn-green">Create Room</button>
                    <div style="margin:15px; color:#555">OR</div>
                    <input type="number" id="codeIn" class="input-code" placeholder="----">
                    <br>
                    <button id="btnJoin" class="btn-blue">Join Room</button>
                </div>
                
                <div id="lobbyWait" class="hidden" style="text-align:center">
                    <p style="color:#888; font-size:12px">ROOM CODE</p>
                    <div style="color:#0f0; font-size:48px; font-family:monospace; margin:10px" id="codeDisp">----</div>
                    <p style="color:#fff; animation: blink 1s infinite">Waiting for opponent...</p>
                </div>
                <button id="btnBack" style="margin-top:40px; width:100px; padding:10px; font-size:12px">Back</button>
            </div>

             <div id="overScreen" class="screen hidden interactive">
                <h1 id="winMsg">WINNER</h1>
                <button onclick="window.location.reload()">MAIN MENU</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.3/pixi.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pixi-filters@5.3.0/dist/browser/pixi-filters.min.js"></script>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
        import { getDatabase, ref, set, onValue, update, remove, get, child, onDisconnect } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

        const firebaseConfig = {
            apiKey: "AIzaSyCzomf89xZhgcPsfYXKsYspCt-CiUVzjBA",
            authDomain: "webarcade-d4c3d.firebaseapp.com",
            projectId: "webarcade-d4c3d",
            storageBucket: "webarcade-d4c3d.firebasestorage.app",
            messagingSenderId: "918209461327",
            appId: "1:918209461327:web:bd9c1a2431f9b5c66ffe3a"
        };

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);

        // --- CONSTANTS ---
        const W = 800; // Logical Width
        const H = 600; // Logical Height
        
        class PongGame {
            constructor() {
                // Initialize Pixi
                this.app = new PIXI.Application({
                    width: W, height: H, backgroundColor: 0x050505,
                    resolution: Math.min(window.devicePixelRatio, 2), // Cap resolution for performance
                    autoDensity: true, antialias: false
                });
                
                document.getElementById('game-layer').appendChild(this.app.view);
                this.wrapper = document.getElementById('game-layer');

                // Game State
                this.state = {
                    playing: false, mode: '', role: '', room: null,
                    score: {L:0, R:0},
                    pL: H/2, pR: H/2, // Paddle positions
                    bx: W/2, by: H/2, bvx: 0, bvy: 0 // Ball physics
                };
                
                this.targetY = H/2; // Where the player wants to move
                this.lastNetUpdate = 0;

                this.initGFX();
                this.initInput();
                this.resize();
                window.addEventListener('resize', () => this.resize());
                
                // Main Loop
                this.app.ticker.add((d) => this.loop(d));
            }

            resize() {
                // Auto-fit Logic: Maintains aspect ratio but fills max screen
                const ratio = W / H;
                let w = window.innerWidth;
                let h = window.innerHeight;
                
                if (w / h >= ratio) { w = h * ratio; } 
                else { h = w / ratio; }

                // Add margins on desktop, full width on mobile
                if(window.innerWidth > 600) { w *= 0.9; h *= 0.9; }
                else { w = window.innerWidth; h = w / ratio; }

                this.wrapper.style.width = w + 'px';
                this.wrapper.style.height = h + 'px';
                this.scale = W / w; // Store scale for input mapping
            }

            initGFX() {
                this.app.stage.filters = [new PIXI.filters.BloomFilter({strength:0.4})];

                // Net
                const net = new PIXI.Graphics();
                net.beginFill(0x222222);
                for(let y=0; y<H; y+=40) net.drawRect(W/2-2, y, 4, 20);
                this.app.stage.addChild(net);

                // Paddles
                this.gfxL = new PIXI.Graphics();
                this.gfxL.beginFill(0xff0055); this.gfxL.drawRect(-10,-50,20,100);
                this.gfxL.x = 40;
                
                this.gfxR = new PIXI.Graphics();
                this.gfxR.beginFill(0x00f3ff); this.gfxR.drawRect(-10,-50,20,100);
                this.gfxR.x = W - 40;

                this.app.stage.addChild(this.gfxL, this.gfxR);

                // Ball
                this.gfxBall = new PIXI.Graphics();
                this.gfxBall.beginFill(0xffffff); this.gfxBall.drawRect(-12,-12,24,24);
                this.app.stage.addChild(this.gfxBall);
            }

            // --- OPTIMIZED INPUT ---
            initInput() {
                const handleMove = (y, isRightSide) => {
                    // Logic: Map the touch Y to Game Y
                    // Constraint: If I am P1, I only care about touches if they are valid
                    if(this.state.mode === 'online') {
                        if(this.state.role === 'host' && isRightSide) return; // Host ignores right side touches
                        if(this.state.role === 'guest' && !isRightSide) return; // Guest ignores left side touches
                    }
                    this.targetY = Math.max(50, Math.min(H-50, y));
                };

                const setupZone = (id, isRight) => {
                    const el = document.getElementById(id);
                    const proc = (e) => {
                        e.preventDefault(); // Stop scrolling!
                        // Get Touch Y relative to the Zone
                        const rect = this.wrapper.getBoundingClientRect();
                        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                        // Map ClientY to Game Coordinates
                        const gameY = (clientY - rect.top) * this.scale;
                        handleMove(gameY, isRight);
                    }
                    el.addEventListener('mousedown', (e) => { proc(e); });
                    el.addEventListener('mousemove', (e) => { if(e.buttons) proc(e); });
                    el.addEventListener('touchstart', (e) => { proc(e); }, {passive:false});
                    el.addEventListener('touchmove', (e) => { proc(e); }, {passive:false});
                };

                setupZone('leftZone', false);
                setupZone('rightZone', true);

                // UI Buttons
                const get = id => document.getElementById(id);
                get('btnAI').onclick = () => this.startAI();
                get('btnOnline').onclick = () => { get('menuScreen').classList.add('hidden'); get('lobbyScreen').classList.remove('hidden'); };
                get('btnHost').onclick = () => this.createRoom();
                get('btnJoin').onclick = () => this.joinRoom();
                get('btnBack').onclick = () => window.location.reload();
            }

            startAI() {
                this.state.mode = 'ai';
                this.state.playing = true;
                this.resetBall();
                document.getElementById('menuScreen').classList.add('hidden');
            }

            // --- PREDICTION PHYSICS LOOP ---
            loop(delta) {
                if(!this.state.playing) return;

                const s = this.state;
                const lerp = (a, b, n) => (1 - n) * a + n * b;

                // 1. Move Player Paddles (Smooth slide towards finger)
                if(s.mode === 'ai') {
                    s.pL = lerp(s.pL, this.targetY, 0.2); // Player is Left
                    // AI Logic
                    let dest = s.by;
                    // Simple "Error" to make AI beatable
                    if(Math.abs(s.bx - s.px) > 300) dest = H/2; 
                    s.pR += (dest - s.pR) * 0.08 * delta;
                } 
                else if (s.mode === 'online') {
                    // Move My Paddle Locally
                    if(s.role === 'host') s.pL = lerp(s.pL, this.targetY, 0.3);
                    else s.pR = lerp(s.pR, this.targetY, 0.3);
                }

                // 2. Ball Physics (Run on BOTH Host and Guest for smoothness)
                // This is "Client Side Prediction"
                s.bx += s.bvx * delta;
                s.by += s.bvy * delta;

                // Wall Bounce
                if(s.by < 10 || s.by > H - 10) { s.bvy *= -1; s.by = Math.max(10, Math.min(H-10, s.by)); }

                // Host Authoritative Collision Logic
                // (Guest simulates it, but Host overrides if there is a conflict)
                if(s.mode === 'ai' || (s.mode === 'online' && s.role === 'host')) {
                    this.checkCollision(s.pL, 40, 1);
                    this.checkCollision(s.pR, W-40, -1);
                    
                    // Score
                    if(s.bx < -20) { s.score.R++; this.resetBall(1); }
                    if(s.bx > W+20) { s.score.L++; this.resetBall(-1); }
                }

                // 3. Update Graphics
                this.gfxL.y = s.pL;
                this.gfxR.y = s.pR;
                this.gfxBall.x = s.bx;
                this.gfxBall.y = s.by;

                // 4. Network Sync (30 FPS)
                if(s.mode === 'online') {
                    const now = Date.now();
                    if(now - this.lastNetUpdate > 33) {
                        this.syncNetwork();
                        this.lastNetUpdate = now;
                    }
                }
            }

            checkCollision(py, px, dir) {
                const s = this.state;
                // AABB Collision
                if (Math.abs(s.bx - px) < 20 && Math.abs(s.by - py) < 60) {
                    s.bvx = Math.abs(s.bvx) * 1.05; // Speed up
                    if (dir === -1) s.bvx *= -1;
                    s.bvy = (s.by - py) * 0.15; // Angle control
                }
            }

            resetBall(dir) {
                const s = this.state;
                s.bx = W/2; s.by = H/2;
                s.bvx = (dir || (Math.random()>.5?1:-1)) * 9; // Slightly faster
                s.bvy = (Math.random()*8)-4;
                this.updateScore();
            }

            updateScore() {
                document.getElementById('scoreL').innerText = this.state.score.L;
                document.getElementById('scoreR').innerText = this.state.score.R;
                if(this.state.score.L >= 10 || this.state.score.R >= 10) {
                    this.state.playing = false;
                    document.getElementById('winMsg').innerText = this.state.score.L > this.state.score.R ? "RED WINS" : "BLUE WINS";
                    document.getElementById('overScreen').classList.remove('hidden');
                    if(this.state.room) remove(ref(db, 'rooms/'+this.state.room));
                }
            }

            // --- NETWORKING ---
            async createRoom() {
                const code = Math.floor(1000 + Math.random() * 9000).toString();
                this.state.room = code;
                this.state.role = 'host';
                
                document.getElementById('lobbyMain').classList.add('hidden');
                document.getElementById('lobbyWait').classList.remove('hidden');
                document.getElementById('codeDisp').innerText = code;

                const r = ref(db, 'rooms/'+code);
                await set(r, { h: true });
                onDisconnect(r).remove();

                onValue(r, (snap) => {
                    const d = snap.val();
                    if(d && d.g && !this.state.playing) {
                        this.state.mode = 'online';
                        this.state.playing = true;
                        this.resetBall();
                        document.getElementById('lobbyScreen').classList.add('hidden');
                    }
                    // Host reads Guest Paddle Y (gy)
                    if(d && d.gy) this.state.pR = d.gy; 
                });
            }

            async joinRoom() {
                const code = document.getElementById('codeIn').value;
                const r = ref(db, 'rooms/'+code);
                const snap = await get(r);
                if(snap.exists()) {
                    this.state.room = code;
                    this.state.role = 'guest';
                    await update(r, { g: true });
                    
                    this.state.mode = 'online';
                    this.state.playing = true;
                    document.getElementById('lobbyScreen').classList.add('hidden');
                    
                    onValue(r, (s) => this.onServerMsg(s.val()));
                } else {
                    alert("Room not found");
                }
            }

            syncNetwork() {
                if(!this.state.room) return;
                const r = ref(db, 'rooms/'+this.state.room);
                
                if(this.state.role === 'host') {
                    // Host sends Ball State (bx, by, bvx, bvy) + Host Paddle (hy) + Score
                    update(r, {
                        bx: Math.round(this.state.bx),
                        by: Math.round(this.state.by),
                        bvx: this.state.bvx,
                        bvy: this.state.bvy,
                        hy: Math.round(this.state.pL),
                        sc: this.state.score
                    });
                } else {
                    // Guest sends Guest Paddle (gy)
                    update(r, { gy: Math.round(this.state.pR) });
                }
            }

            onServerMsg(data) {
                if(!data || !this.state.playing) return;
                
                if(this.state.role === 'guest') {
                    const s = this.state;
                    
                    // Sync Host Paddle
                    if(data.hy) s.pL = data.hy; 
                    
                    // Sync Score
                    if(data.sc) { s.score = data.sc; this.updateScore(); }

                    // BALL SYNC & SMOOTHING (The Magic Fix)
                    if(data.bx !== undefined) {
                        // Calculate distance between Local Ball and Server Ball
                        const dx = s.bx - data.bx;
                        const dy = s.by - data.by;
                        const dist = Math.sqrt(dx*dx + dy*dy);

                        // If discrepancy is small (< 50px), just nudge velocity to correct it
                        // This keeps it smooth.
                        if(dist < 50) {
                            s.bx += (data.bx - s.bx) * 0.1; 
                            s.by += (data.by - s.by) * 0.1;
                            // Still adopt server velocity so we don't drift further
                            s.bvx = data.bvx; 
                            s.bvy = data.bvy;
                        } 
                        // If discrepancy is huge (Lag spike), teleport to sync
                        else {
                            s.bx = data.bx; s.by = data.by;
                            s.bvx = data.bvx; s.bvy = data.bvy;
                        }
                    }
                }
            }
        }

        new PongGame();
    </script>
</body>
</html>
