<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Pong - WebRTC Edition</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; user-select: none; -webkit-tap-highlight-color: transparent; }
        body { background-color: #000; overflow: hidden; width: 100vw; height: 100vh; font-family: "Courier New", Courier, monospace; display: flex; justify-content: center; align-items: center; }
        canvas { display: block; box-shadow: 0 0 50px rgba(0, 255, 255, 0.2); background: #050505; }
        
        .touch-zone { 
            position: absolute; 
            top: 0; bottom: 0; width: 50%; 
            z-index: 5; pointer-events: auto;
            transition: background 0.3s;
        }
        .touch-zone.active { background: rgba(255,255,255,0.05); }
        #leftZone { left: 0; }
        #rightZone { right: 0; }
        
        .touch-indicator {
            position: absolute; width: 60px; height: 60px;
            border: 3px solid rgba(255,255,255,0.6);
            border-radius: 50%; pointer-events: none;
            transform: translate(-50%, -50%);
            opacity: 0; transition: opacity 0.2s;
            z-index: 6;
        }
        .touch-indicator.visible { opacity: 1; }

        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 20; display: flex; flex-direction: column; align-items: center; }
        .interactive { pointer-events: auto; }
        .hud { width: 100%; padding: 20px 16px; display: flex; flex-direction: column; align-items: center; pointer-events: none; }
        
        .score-row { 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            width: 100%; 
            margin-top: 60px;
        }
        .score-box { 
            display: flex; 
            gap: clamp(40px, 12vw, 60px); 
            font-size: clamp(36px, 11vw, 60px); 
            font-weight: bold; 
            text-shadow: 0 0 10px currentColor; 
        }
        .player-info { 
            display: flex; 
            justify-content: space-between; 
            width: 100%; 
            max-width: 500px; 
            margin-top: 8px; 
            font-weight: bold; 
            letter-spacing: 2px; 
            font-size: clamp(10px, 2.8vw, 14px); 
            padding: 0 10px;
        }
        .label-l { color: #ff0055; text-shadow: 0 0 5px #ff0055; }
        .label-r { color: #00f3ff; text-shadow: 0 0 5px #00f3ff; }
        
        .screen { position: absolute; inset: 0; background: rgba(0,0,0,0.95); backdrop-filter: blur(4px); display: flex; flex-direction: column; align-items: center; justify-content: center; transition: opacity 0.3s; padding: 20px; overflow-y: auto; pointer-events: auto; }
        .hidden { opacity: 0; pointer-events: none; }
        h1 { color: #fff; font-size: clamp(24px, 7vw, 50px); margin-bottom: clamp(12px, 3vh, 30px); letter-spacing: clamp(2px, 1vw, 5px); text-shadow: 0 0 20px #00f3ff; text-transform: uppercase; text-align: center; }
        h2 { font-size: clamp(36px, 10vw, 60px); }
        button { background: rgba(0,0,0,0.6); border: 2px solid #fff; color: #fff; padding: clamp(8px, 2vh, 15px) clamp(16px, 5vw, 40px); margin: clamp(4px, 1vh, 10px); font-size: clamp(12px, 3.2vw, 18px); font-weight: bold; letter-spacing: 2px; text-transform: uppercase; cursor: pointer; box-shadow: 0 0 10px rgba(255,255,255,0.1); transition: all 0.2s; min-width: clamp(130px, 40vw, 200px); }
        button:active { transform: scale(0.95); background: #222; }
        button:disabled { opacity: 0.5; cursor: not-allowed; transform: none !important; }
        .btn-cyan { border-color: #00f3ff; color: #00f3ff; text-shadow: 0 0 5px #00f3ff; box-shadow: 0 0 10px rgba(0, 243, 255, 0.3); }
        .btn-pink { border-color: #ff0055; color: #ff0055; text-shadow: 0 0 5px #ff0055; box-shadow: 0 0 10px rgba(255, 0, 85, 0.3); }
        .btn-exit { position: absolute; top: 12px; left: 12px; border-color: #ff3333; color: #ff3333; padding: clamp(6px, 1.5vh, 10px) clamp(10px, 3vw, 20px); min-width: auto; font-size: clamp(10px, 2.8vw, 14px); box-shadow: 0 0 5px rgba(255, 50, 50, 0.5); z-index: 100; pointer-events: auto; }
        input { background: transparent; border: none; border-bottom: 2px solid #00f3ff; color: #fff; font-size: clamp(20px, 6vw, 30px); text-align: center; letter-spacing: 5px; width: clamp(120px, 45vw, 200px); margin: clamp(8px, 2vh, 20px); outline: none; padding: clamp(6px, 1.5vh, 10px); }
        input::-webkit-outer-spin-button, input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        input[type=number] { -moz-appearance: textfield; }
        .lobby-divider { color: #666; margin: clamp(4px, 1vh, 10px) 0; font-size: clamp(11px, 3vw, 16px); }
        .btn-back { font-size: clamp(10px, 2.5vw, 12px) !important; min-width: clamp(80px, 25vw, 100px) !important; border-color: #555 !important; color: #aaa !important; margin-top: clamp(6px, 1.5vh, 8px); }
        .feedback-text { color: #ff3333; font-size: clamp(10px, 2.8vw, 13px); min-height: 1.4em; margin-top: 4px; letter-spacing: 1px; text-transform: uppercase; }
        .room-code-label { color: #aaa; font-size: clamp(11px, 3vw, 16px); }
        .room-code-display { color: #0f0; font-size: clamp(36px, 10vw, 60px); margin: 6px 0; text-shadow: 0 0 20px #0f0; }
        .waiting-text { color: #fff; margin-top: clamp(8px, 2vh, 20px); font-size: clamp(12px, 3.2vw, 16px); }
        .error-notice { color: #ff6b6b; background: rgba(255, 0, 0, 0.1); border: 1px solid #ff3333; padding: 10px 15px; border-radius: 8px; margin-top: 10px; font-size: clamp(10px, 2.5vw, 12px); max-width: 90%; text-align: center; z-index: 1000; position: relative; }
        .back-btn-link { position: absolute; top: 12px; right: 12px; background: rgba(0,0,0,0.6); border: 2px solid #555; color: #aaa; padding: clamp(6px, 1.5vh, 10px) clamp(10px, 3vw, 20px); text-decoration: none; font-weight: bold; font-size: clamp(10px, 2.8vw, 14px); border-radius: 4px; text-transform: uppercase; z-index: 100; display: inline-block; }
        .back-btn-link:hover { background: rgba(50,50,50,0.8); }
        
        .connection-status {
            position: absolute; top: 50px; right: 12px;
            background: rgba(0,0,0,0.8); border: 2px solid;
            padding: 6px 12px; border-radius: 8px;
            font-size: 11px; font-weight: bold;
            z-index: 101; display: none;
        }
        .connection-status.connected { border-color: #0f0; color: #0f0; }
        .connection-status.disconnected { border-color: #f00; color: #f00; }
        .connection-status.connecting { border-color: #ff0; color: #ff0; }

        .latency-display {
            position: absolute; top: 90px; right: 12px;
            background: rgba(0,0,0,0.8); border: 2px solid #00f3ff;
            padding: 6px 12px; border-radius: 8px;
            font-size: 11px; font-weight: bold;
            color: #00f3ff;
            z-index: 101; display: none;
        }

        .loading-spinner {
            border: 3px solid rgba(0, 243, 255, 0.2);
            border-top: 3px solid #00f3ff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 10px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="leftZone" class="touch-zone"></div>
    <div id="rightZone" class="touch-zone"></div>
    <div id="touchIndicator" class="touch-indicator"></div>

    <div class="ui-layer">
        <div class="hud hidden" id="gameHud">
            <button class="btn-exit interactive" id="btnExit">EXIT</button>
            <a href="blog.html" class="back-btn-link">← DASH</a>
            <div id="connectionStatus" class="connection-status"></div>
            <div id="latencyDisplay" class="latency-display">RTT: --ms</div>
            <div class="score-row">
                <div class="score-box">
                    <div style="color:#ff0055" id="scoreL">0</div>
                    <div style="color:#00f3ff" id="scoreR">0</div>
                </div>
            </div>
            <div class="player-info">
                <span class="label-l" id="labelL">PLAYER 1</span>
                <span class="label-r" id="labelR">PLAYER 2</span>
            </div>
        </div>

        <div id="menuScreen" class="screen interactive">
            <h1>NEON PONG</h1>
            <button class="btn-cyan" id="btnAI">SINGLE PLAYER</button>
            <button class="btn-pink" id="btnOnline">MULTIPLAYER</button>
            <a href="blog.html" class="btn-back" style="text-decoration:none; display:inline-block;">← DASHBOARD</a>
            <div id="connectionError" class="error-notice hidden"></div>
        </div>

        <div id="lobbyScreen" class="screen hidden interactive">
            <h1>LOBBY</h1>
            <div id="lobbyMain" style="text-align:center; display:flex; flex-direction:column; align-items:center;">
                <button id="btnHost" class="btn-cyan">CREATE ROOM</button>
                <div class="lobby-divider">--- OR JOIN ---</div>
                <input type="number" id="codeIn" placeholder="CODE" inputmode="numeric" maxlength="4" pattern="[0-9]*" autocomplete="off" min="1000" max="9999">
                <div class="feedback-text" id="joinFeedback"></div>
                <button id="btnJoin" class="btn-pink">JOIN GAME</button>
                <button id="btnBack" class="btn-back">BACK</button>
            </div>
            
            <div id="lobbyWait" class="hidden" style="text-align:center; display:flex; flex-direction:column; align-items:center;">
                <p class="room-code-label">ROOM CODE:</p>
                <h2 class="room-code-display" id="codeDisp">----</h2>
                <p class="waiting-text">Waiting for opponent...</p>
                <button id="btnCancelHost" class="btn-back" style="margin-top: 20px;">CANCEL</button>
            </div>
        </div>

        <div id="overScreen" class="screen hidden interactive">
            <h1 id="winMsg">WINNER</h1>
            <button class="btn-cyan" onclick="window.location.reload()">PLAY AGAIN</button>
            <a href="blog.html" class="btn-back" style="text-decoration:none; display:inline-block;">← DASHBOARD</a>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.3/pixi.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pixi-filters@5.3.0/dist/browser/pixi-filters.min.js"></script>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
        import { getDatabase, ref, set, onValue, update, remove, get, onDisconnect, off } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";
        import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";

        const firebaseConfig = {
            apiKey: "AIzaSyCzomf89xZhgcPsfYXKsYspCt-CiUVzjBA",
            authDomain: "webarcade-d4c3d.firebaseapp.com",
            databaseURL: "https://webarcade-d4c3d-default-rtdb.firebaseio.com",
            projectId: "webarcade-d4c3d",
            storageBucket: "webarcade-d4c3d.firebasestorage.app",
            messagingSenderId: "918209461327",
            appId: "1:918209461327:web:bd9c1a2431f9b5c66ffe3a"
        };

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);
        const auth = getAuth(app);

        // Game Constants
        const W = 800, H = 600;
        const BALL_RADIUS = 8, PADDLE_WIDTH = 16, PADDLE_HEIGHT = 100;
        const BALL_BASE_SPEED_X = 420, BALL_MAX_SPEED = 850, BALL_ACCEL_FACTOR = 1.07;
        const PADDLE_MIN_Y = PADDLE_HEIGHT/2 + 10, PADDLE_MAX_Y = H - PADDLE_HEIGHT/2 - 10;
        const WIN_SCORE = 10;
        const PHYSICS_HZ = 120; // Fixed physics timestep
        const NETWORK_HZ = 120; // Network update rate
        const PHYSICS_DT = 1000 / PHYSICS_HZ;
        const NETWORK_DT = 1000 / NETWORK_HZ;

        // WebRTC Configuration
        const ICE_SERVERS = [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' },
            { urls: 'stun:stun2.l.google.com:19302' }
        ];

        // Physics Engine - Authoritative on Host
        class PhysicsEngine {
            constructor() {
                this.bx = W / 2;
                this.by = H / 2;
                this.bvx = 0;
                this.bvy = 0;
                this.pL = H / 2;
                this.pR = H / 2;
                this.scoreL = 0;
                this.scoreR = 0;
                this.lastHitTimeL = 0;
                this.lastHitTimeR = 0;
                this.accumulator = 0;
            }

            reset(dir) {
                this.bx = W / 2;
                this.by = H / 2;
                const d = dir || (Math.random() > 0.5 ? 1 : -1);
                this.bvx = d * BALL_BASE_SPEED_X;
                this.bvy = (Math.random() * 70 + 70) * (Math.random() > 0.5 ? 1 : -1);
            }

            update(dt) {
                // Fixed timestep physics
                this.accumulator += dt;
                
                while (this.accumulator >= PHYSICS_DT) {
                    this.step(PHYSICS_DT / 1000); // Convert to seconds
                    this.accumulator -= PHYSICS_DT;
                }
            }

            step(dt) {
                // Ball movement
                this.bx += this.bvx * dt;
                this.by += this.bvy * dt;

                // Wall collisions
                if (this.by - BALL_RADIUS < 0) {
                    this.by = BALL_RADIUS;
                    this.bvy = Math.abs(this.bvy) * 0.98;
                } else if (this.by + BALL_RADIUS > H) {
                    this.by = H - BALL_RADIUS;
                    this.bvy = -Math.abs(this.bvy) * 0.98;
                }

                // Paddle collisions
                this.checkPaddleHit(this.pL, 30, 1);
                this.checkPaddleHit(this.pR, W - 30, -1);

                // Scoring
                if (this.bx + BALL_RADIUS < 0) {
                    this.scoreR++;
                    return 'scoreR';
                } else if (this.bx - BALL_RADIUS > W) {
                    this.scoreL++;
                    return 'scoreL';
                }

                return null;
            }

            checkPaddleHit(py, px, dir) {
                const now = Date.now();
                const cooldown = (dir === 1) ? this.lastHitTimeL : this.lastHitTimeR;
                if (now - cooldown < 80) return;

                const movingToward = (dir === 1 && this.bvx < 0) || (dir === -1 && this.bvx > 0);
                if (!movingToward) return;

                const closestX = Math.max(px - PADDLE_WIDTH/2, Math.min(this.bx, px + PADDLE_WIDTH/2));
                const closestY = Math.max(py - PADDLE_HEIGHT/2, Math.min(this.by, py + PADDLE_HEIGHT/2));
                const distSq = (this.bx - closestX) ** 2 + (this.by - closestY) ** 2;

                if (distSq <= BALL_RADIUS ** 2) {
                    if (dir === 1) this.lastHitTimeL = now;
                    else this.lastHitTimeR = now;

                    let newSpeed = Math.min(Math.abs(this.bvx) * BALL_ACCEL_FACTOR, BALL_MAX_SPEED);
                    this.bvx = newSpeed * dir;

                    const relativePos = (this.by - py) / (PADDLE_HEIGHT/2);
                    this.bvy = relativePos * newSpeed * 0.45;
                    this.bvy = Math.max(-newSpeed * 0.55, Math.min(newSpeed * 0.55, this.bvy));

                    const pushout = Math.max(BALL_RADIUS + PADDLE_WIDTH/2 + 5, Math.abs(this.bvx) * 0.03);
                    this.bx = (dir === 1) ? (px + pushout) : (px - pushout);
                    this.bx = Math.max(BALL_RADIUS + 5, Math.min(W - BALL_RADIUS - 5, this.bx));
                }
            }

            getState() {
                return {
                    bx: this.bx,
                    by: this.by,
                    bvx: this.bvx,
                    bvy: this.bvy,
                    pL: this.pL,
                    pR: this.pR,
                    scoreL: this.scoreL,
                    scoreR: this.scoreR
                };
            }

            setState(state) {
                this.bx = state.bx;
                this.by = state.by;
                this.bvx = state.bvx;
                this.bvy = state.bvy;
                this.pL = state.pL;
                this.pR = state.pR;
                this.scoreL = state.scoreL;
                this.scoreR = state.scoreR;
            }
        }

        // Client-Side Prediction for Guest
        class PredictionEngine {
            constructor() {
                this.bx = W / 2;
                this.by = H / 2;
                this.bvx = 0;
                this.bvy = 0;
                this.targetBx = W / 2;
                this.targetBy = H / 2;
                this.targetVx = 0;
                this.targetVy = 0;
                this.lerpFactor = 0.4; // Increased for faster correction
            }

            predict(dt) {
                // Predict ball movement
                this.bx += this.bvx * dt;
                this.by += this.bvy * dt;

                // Wall bounces (same as physics)
                if (this.by - BALL_RADIUS < 0) {
                    this.by = BALL_RADIUS;
                    this.bvy = Math.abs(this.bvy) * 0.98;
                } else if (this.by + BALL_RADIUS > H) {
                    this.by = H - BALL_RADIUS;
                    this.bvy = -Math.abs(this.bvy) * 0.98;
                }

                // Smooth interpolation to server state
                this.bx += (this.targetBx - this.bx) * this.lerpFactor;
                this.by += (this.targetBy - this.by) * this.lerpFactor;
                this.bvx += (this.targetVx - this.bvx) * this.lerpFactor;
                this.bvy += (this.targetVy - this.bvy) * this.lerpFactor;
            }

            updateTarget(bx, by, vx, vy) {
                this.targetBx = bx;
                this.targetBy = by;
                this.targetVx = vx;
                this.targetVy = vy;
            }

            hardSet(bx, by, vx, vy) {
                this.bx = this.targetBx = bx;
                this.by = this.targetBy = by;
                this.bvx = this.targetVx = vx;
                this.bvy = this.targetVy = vy;
            }
        }

        // WebRTC Manager
        class WebRTCManager {
            constructor(isHost, onMessage, onConnectionChange) {
                this.isHost = isHost;
                this.onMessage = onMessage;
                this.onConnectionChange = onConnectionChange;
                this.pc = null;
                this.dataChannel = null;
                this.connected = false;
                this.signalRef = null;
                this.signalListener = null;
                
                // Latency tracking
                this.lastPingTime = 0;
                this.rtt = 0; // Round-trip time in ms
                this.pingInterval = null;
            }

            async init(roomCode) {
                this.pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });

                // ICE candidate handling
                this.pc.onicecandidate = (event) => {
                    if (event.candidate) {
                        const path = this.isHost ? 'hostIce' : 'guestIce';
                        update(ref(db, `rooms/${roomCode}/${path}`), {
                            [Date.now()]: JSON.stringify(event.candidate.toJSON())
                        }).catch(console.error);
                    }
                };

                // Connection state monitoring
                this.pc.onconnectionstatechange = () => {
                    console.log('Connection state:', this.pc.connectionState);
                    this.onConnectionChange(this.pc.connectionState);
                    
                    if (this.pc.connectionState === 'connected') {
                        this.connected = true;
                        this.startPingMonitoring();
                    } else if (this.pc.connectionState === 'disconnected' || 
                               this.pc.connectionState === 'failed') {
                        this.connected = false;
                        this.stopPingMonitoring();
                    }
                };

                if (this.isHost) {
                    // Host creates data channel
                    this.dataChannel = this.pc.createDataChannel('gameData', {
                        ordered: false,      // Allow out-of-order delivery
                        maxRetransmits: 0    // No retransmission for lowest latency
                    });
                    this.setupDataChannel();

                    // Create offer
                    const offer = await this.pc.createOffer();
                    await this.pc.setLocalDescription(offer);
                    await set(ref(db, `rooms/${roomCode}/offer`), JSON.stringify(offer));

                    // Listen for answer
                    this.signalRef = ref(db, `rooms/${roomCode}/answer`);
                    this.signalListener = onValue(this.signalRef, async (snap) => {
                        const answer = snap.val();
                        if (answer && this.pc.remoteDescription === null) {
                            await this.pc.setRemoteDescription(JSON.parse(answer));
                        }
                    });
                } else {
                    // Guest receives data channel
                    this.pc.ondatachannel = (event) => {
                        this.dataChannel = event.channel;
                        this.setupDataChannel();
                    };

                    // Wait for offer
                    this.signalRef = ref(db, `rooms/${roomCode}/offer`);
                    this.signalListener = onValue(this.signalRef, async (snap) => {
                        const offer = snap.val();
                        if (offer && this.pc.remoteDescription === null) {
                            await this.pc.setRemoteDescription(JSON.parse(offer));
                            const answer = await this.pc.createAnswer();
                            await this.pc.setLocalDescription(answer);
                            await set(ref(db, `rooms/${roomCode}/answer`), JSON.stringify(answer));
                        }
                    });
                }

                // Listen for ICE candidates
                const icePath = this.isHost ? 'guestIce' : 'hostIce';
                const iceRef = ref(db, `rooms/${roomCode}/${icePath}`);
                onValue(iceRef, (snap) => {
                    const candidates = snap.val();
                    if (candidates) {
                        Object.values(candidates).forEach(async (cand) => {
                            try {
                                await this.pc.addIceCandidate(JSON.parse(cand));
                            } catch (e) {
                                console.error('Error adding ICE candidate:', e);
                            }
                        });
                    }
                });
            }

            setupDataChannel() {
                this.dataChannel.onopen = () => {
                    console.log('Data channel open');
                    this.connected = true;
                    this.onConnectionChange('connected');
                };

                this.dataChannel.onclose = () => {
                    console.log('Data channel closed');
                    this.connected = false;
                    this.onConnectionChange('disconnected');
                };

                this.dataChannel.onerror = (error) => {
                    console.error('Data channel error:', error);
                };

                this.dataChannel.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        
                        // Handle ping/pong for latency measurement
                        if (data.type === 'ping') {
                            this.send({ type: 'pong', timestamp: data.timestamp });
                            return;
                        } else if (data.type === 'pong') {
                            this.rtt = Date.now() - data.timestamp;
                            return;
                        }
                        
                        this.onMessage(data);
                    } catch (e) {
                        console.error('Error parsing message:', e);
                    }
                };
            }

            send(data) {
                if (this.dataChannel && this.dataChannel.readyState === 'open') {
                    try {
                        this.dataChannel.send(JSON.stringify(data));
                    } catch (e) {
                        console.error('Send error:', e);
                    }
                }
            }

            startPingMonitoring() {
                this.pingInterval = setInterval(() => {
                    if (this.connected) {
                        this.send({ type: 'ping', timestamp: Date.now() });
                    }
                }, 1000); // Ping every second
            }

            stopPingMonitoring() {
                if (this.pingInterval) {
                    clearInterval(this.pingInterval);
                    this.pingInterval = null;
                }
            }

            async cleanup() {
                this.stopPingMonitoring();
                
                if (this.signalListener && this.signalRef) {
                    off(this.signalRef);
                }
                
                if (this.dataChannel) {
                    this.dataChannel.close();
                }
                
                if (this.pc) {
                    this.pc.close();
                }
                
                this.connected = false;
            }
        }

        // Main Game Class
        class PongGame {
            constructor() {
                const oldCanvas = document.querySelector('canvas');
                if(oldCanvas) oldCanvas.remove();

                this.app = new PIXI.Application({
                    width: W, height: H, backgroundColor: 0x050505,
                    resolution: window.devicePixelRatio || 1,
                    autoDensity: true, antialias: true
                });
                
                document.body.appendChild(this.app.view);
                
                this.state = {
                    playing: false, 
                    mode: '', 
                    role: '', 
                    room: null,
                    playerName: '', 
                    opponentName: ''
                };
                
                this.inputY = H/2;
                this.scaleFactor = 1;
                this.eventCleanup = [];
                this.authReady = false;
                this.currentUser = null;
                this.gameStopped = false;
                this.isCleaningUp = false;

                // Physics engines
                this.physics = new PhysicsEngine();
                this.prediction = new PredictionEngine();
                
                // WebRTC
                this.webrtc = null;
                this.lastNetworkUpdate = 0;

                // Rendering state
                this.renderState = {
                    pL: H/2,
                    pR: H/2,
                    bx: W/2,
                    by: H/2,
                    scoreL: 0,
                    scoreR: 0
                };

                this.initGFX();
                this.initAuth();
                this.initUI();
                this.initInput();
                this.resize();
                
                const resizeHandler = () => this.resize();
                window.addEventListener('resize', resizeHandler);
                this.eventCleanup.push(() => window.removeEventListener('resize', resizeHandler));
                
                this.app.ticker.add((delta) => this.loop(delta));
            }

            initAuth() {
                onAuthStateChanged(auth, (user) => {
                    this.currentUser = user;
                    this.authReady = true;
                    
                    if (!user) {
                        console.warn('No user logged in - username will default to "Player"');
                    }
                });
            }

            resize() {
                const scale = Math.min(window.innerWidth / W, window.innerHeight / H);
                this.app.view.style.width  = `${W * scale}px`;
                this.app.view.style.height = `${H * scale}px`;
                this.scaleFactor = scale;
            }

            initGFX() {
                try {
                    if(PIXI.filters?.BloomFilter) {
                        const quality = window.devicePixelRatio > 1 ? 2 : 3;
                        this.app.stage.filters = [new PIXI.filters.BloomFilter({strength: 0.3, quality, blur: 6})];
                    }
                } catch(e) {}
                
                const net = new PIXI.Graphics();
                net.beginFill(0x333333);
                for(let y = 10; y < H; y += 30) net.drawRect(W/2 - 1, y, 2, 15);
                net.endFill();
                this.app.stage.addChild(net);

                const makePad = (c, x) => {
                    const g = new PIXI.Graphics();
                    g.beginFill(c);
                    g.drawRoundedRect(-PADDLE_WIDTH/2, -PADDLE_HEIGHT/2, PADDLE_WIDTH, PADDLE_HEIGHT, 4);
                    g.endFill();
                    g.beginFill(0xffffff, 0.3);
                    g.drawRoundedRect(-PADDLE_WIDTH/2 + 2, -PADDLE_HEIGHT/2 + 2, PADDLE_WIDTH - 4, PADDLE_HEIGHT - 4, 3);
                    g.endFill();
                    g.x = x; g.y = H/2;
                    this.app.stage.addChild(g);
                    return g;
                };
                this.gfxL = makePad(0xff0055, 30);
                this.gfxR = makePad(0x00f3ff, W - 30);

                this.ball = new PIXI.Graphics();
                this.ball.beginFill(0xffffff);
                this.ball.drawCircle(0, 0, BALL_RADIUS);
                this.ball.endFill();
                this.ball.x = W/2; this.ball.y = H/2;
                this.app.stage.addChild(this.ball);
                
                this.ballTrail = new PIXI.Graphics();
                this.app.stage.addChildAt(this.ballTrail, 1);
            }

            initInput() {
                const touchIndicator = document.getElementById('touchIndicator');
                
                const onInput = (clientY, show = false) => {
                    if(!this.state.playing) return;
                    const rect = this.app.view.getBoundingClientRect();
                    let relativeY = (clientY - rect.top) / this.scaleFactor;
                    this.inputY = Math.max(PADDLE_MIN_Y, Math.min(PADDLE_MAX_Y, relativeY));
                    
                    if(show) {
                        const canvasCenterX = rect.left + (rect.width * this.scaleFactor * 0.5);
                        touchIndicator.style.left = canvasCenterX + 'px';
                        touchIndicator.style.top = clientY + 'px';
                        touchIndicator.classList.add('visible');
                    }
                };

                const mouseMoveHandler = (e) => onInput(e.clientY);
                window.addEventListener('mousemove', mouseMoveHandler);
                this.eventCleanup.push(() => window.removeEventListener('mousemove', mouseMoveHandler));

                const zones = document.querySelectorAll('.touch-zone');
                zones.forEach(z => {
                    const handlers = {
                        start: (e) => {
                            e.preventDefault();
                            z.classList.add('active');
                            for(let i = 0; i < e.touches.length; i++) {
                                onInput(e.touches[i].clientY, true);
                            }
                        },
                        move: (e) => {
                            e.preventDefault();
                            if(e.touches.length > 0) onInput(e.touches[0].clientY, true);
                        },
                        end: (e) => {
                            e.preventDefault();
                            z.classList.remove('active');
                            touchIndicator.classList.remove('visible');
                        }
                    };
                    
                    z.addEventListener('touchstart', handlers.start, { passive: false });
                    z.addEventListener('touchmove', handlers.move, { passive: false });
                    z.addEventListener('touchend', handlers.end, { passive: false });
                    z.addEventListener('touchcancel', handlers.end, { passive: false });
                    
                    this.eventCleanup.push(() => {
                        z.removeEventListener('touchstart', handlers.start);
                        z.removeEventListener('touchmove', handlers.move);
                        z.removeEventListener('touchend', handlers.end);
                        z.removeEventListener('touchcancel', handlers.end);
                    });
                });
                
                const keyHandler = (e) => {
                    if(!this.state.playing) return;
                    if(e.key === 'ArrowUp') this.inputY = Math.max(PADDLE_MIN_Y, this.inputY - 20);
                    if(e.key === 'ArrowDown') this.inputY = Math.min(PADDLE_MAX_Y, this.inputY + 20);
                };
                window.addEventListener('keydown', keyHandler);
                this.eventCleanup.push(() => window.removeEventListener('keydown', keyHandler));
            }

            initUI() {
                const el = id => document.getElementById(id);
                el('btnAI').onclick = () => this.startAI();
                el('btnOnline').onclick = () => this.showLobby();
                el('btnBack').onclick = () => this.hideLobby();
                el('btnHost').onclick = () => this.host();
                el('btnJoin').onclick = () => this.join();
                el('btnExit').onclick = () => this.manualExit();
                el('btnCancelHost').onclick = () => this.cancelHosting();
                el('codeIn').addEventListener('keypress', (e) => {
                    if(e.key === 'Enter') { e.preventDefault(); this.join(); }
                });
            }

            async getPlayerName() {
                try {
                    if (this.currentUser) {
                        const userRef = ref(db, 'users/' + this.currentUser.uid + '/username');
                        const snap = await get(userRef);
                        if (snap.exists()) {
                            return snap.val();
                        }
                    }
                } catch(e) {
                    console.error('Error fetching username:', e);
                }
                return 'Player';
            }

            updatePlayerLabels() {
                const labelL = document.getElementById('labelL');
                const labelR = document.getElementById('labelR');
                
                if(this.state.mode === 'ai') {
                    labelL.textContent = this.state.playerName.toUpperCase();
                    labelR.textContent = 'AI';
                } else if(this.state.mode === 'online') {
                    if(this.state.role === 'host') {
                        labelL.textContent = this.state.playerName.toUpperCase();
                        labelR.textContent = this.state.opponentName.toUpperCase();
                    } else {
                        labelL.textContent = this.state.opponentName.toUpperCase();
                        labelR.textContent = this.state.playerName.toUpperCase();
                    }
                }
            }

            showLobby() {
                document.getElementById('menuScreen').classList.add('hidden');
                document.getElementById('lobbyScreen').classList.remove('hidden');
            }

            hideLobby() {
                document.getElementById('lobbyScreen').classList.add('hidden');
                document.getElementById('menuScreen').classList.remove('hidden');
                document.getElementById('joinFeedback').textContent = '';
                ['btnJoin', 'btnHost'].forEach(id => document.getElementById(id).disabled = false);
            }

            async startAI() {
                this.state.playerName = await this.getPlayerName();
                this.state = {...this.state, mode: 'ai', playing: true};
                this.gameStopped = false;
                
                this.physics.scoreL = 0;
                this.physics.scoreR = 0;
                this.physics.reset();
                
                this.updateScoreDisplay();
                this.updatePlayerLabels();
                
                document.getElementById('menuScreen').classList.add('hidden');
                document.getElementById('gameHud').classList.remove('hidden');
                document.getElementById('connectionStatus').style.display = 'none';
                document.getElementById('latencyDisplay').style.display = 'none';
            }

            async manualExit() {
                await this.cleanup();
                window.location.reload();
            }

            async cancelHosting() {
                await this.cleanup();
                document.getElementById('lobbyWait').classList.add('hidden');
                document.getElementById('lobbyMain').classList.remove('hidden');
                ['btnJoin', 'btnHost'].forEach(id => document.getElementById(id).disabled = false);
            }

            async cleanup() {
                if(this.isCleaningUp) return;
                this.isCleaningUp = true;

                this.eventCleanup.forEach(fn => fn());
                this.eventCleanup = [];

                if (this.webrtc) {
                    await this.webrtc.cleanup();
                    this.webrtc = null;
                }

                if(this.state.room) {
                    const room = this.state.room;
                    this.state.room = null;
                    
                    try {
                        await remove(ref(db, 'rooms/' + room));
                    } catch(e) {}
                }
                
                this.isCleaningUp = false;
            }

            stopGame(reason) {
                if(this.gameStopped) return;
                this.gameStopped = true;
                this.state.playing = false;
                
                this.ballTrail.clear();
                document.getElementById('gameHud').classList.add('hidden');
                document.getElementById('winMsg').innerText = reason || "GAME OVER";
                document.getElementById('overScreen').classList.remove('hidden');
                document.getElementById('connectionStatus').style.display = 'none';
                document.getElementById('latencyDisplay').style.display = 'none';
            }

            updateConnectionStatus(status) {
                const statusEl = document.getElementById('connectionStatus');
                const latencyEl = document.getElementById('latencyDisplay');
                
                if(this.state.mode === 'online' && this.state.playing) {
                    statusEl.style.display = 'block';
                    statusEl.className = 'connection-status';
                    
                    if (status === 'connected') {
                        statusEl.classList.add('connected');
                        statusEl.textContent = 'CONNECTED';
                        latencyEl.style.display = 'block';
                    } else if (status === 'connecting') {
                        statusEl.classList.add('connecting');
                        statusEl.textContent = 'CONNECTING...';
                        latencyEl.style.display = 'none';
                    } else {
                        statusEl.classList.add('disconnected');
                        statusEl.textContent = 'DISCONNECTED';
                        latencyEl.style.display = 'none';
                    }
                } else {
                    statusEl.style.display = 'none';
                    latencyEl.style.display = 'none';
                }
            }

            updateLatencyDisplay() {
                if (this.webrtc && this.webrtc.rtt > 0) {
                    document.getElementById('latencyDisplay').textContent = `RTT: ${this.webrtc.rtt}ms`;
                }
            }

            updateScoreDisplay() {
                document.getElementById('scoreL').innerText = this.renderState.scoreL;
                document.getElementById('scoreR').innerText = this.renderState.scoreR;
            }

            loop(delta) {
                if(!this.state.playing) return;
                
                const dt = this.app.ticker.elapsedMS;

                if(this.state.mode === 'ai') {
                    this.updateAI(dt);
                } else if(this.state.mode === 'online') {
                    this.updateOnline(dt);
                }

                this.render();
            }

            updateAI(dt) {
                // Update input
                this.physics.pL = this.inputY;

                // AI logic
                const aiBaseSpeed = 320;
                const aiSpeedBoost = Math.abs(this.physics.bvx) * 0.22;
                const aiSpeed = Math.min(500, aiBaseSpeed + aiSpeedBoost);
                const target = this.physics.bx > W / 2 ? this.physics.by : H / 2;
                const diff = target - this.physics.pR;
                const maxMove = aiSpeed * (dt / 1000);
                this.physics.pR = Math.abs(diff) <= maxMove ? target : this.physics.pR + Math.sign(diff) * maxMove;
                this.physics.pR = Math.max(PADDLE_MIN_Y, Math.min(PADDLE_MAX_Y, this.physics.pR));

                // Update physics
                const result = this.physics.update(dt);
                
                if (result) {
                    this.physics.reset(result === 'scoreL' ? -1 : 1);
                    
                    if (this.physics.scoreL >= WIN_SCORE || this.physics.scoreR >= WIN_SCORE) {
                        const winner = this.physics.scoreL > this.physics.scoreR ? "YOU WIN!" : "YOU LOST!";
                        this.stopGame(winner);
                    }
                }

                // Update render state
                this.renderState.pL = this.physics.pL;
                this.renderState.pR = this.physics.pR;
                this.renderState.bx = this.physics.bx;
                this.renderState.by = this.physics.by;
                this.renderState.scoreL = this.physics.scoreL;
                this.renderState.scoreR = this.physics.scoreR;
            }

            updateOnline(dt) {
                const now = Date.now();

                if (this.state.role === 'host') {
                    // Host: Run authoritative physics
                    this.physics.pL = this.inputY;
                    
                    const result = this.physics.update(dt);
                    
                    if (result) {
                        this.physics.reset(result === 'scoreL' ? -1 : 1);
                        
                        if (this.physics.scoreL >= WIN_SCORE || this.physics.scoreR >= WIN_SCORE) {
                            const winner = "YOU " + (this.physics.scoreL > this.physics.scoreR ? "WIN!" : "LOST!");
                            this.stopGame(winner);
                            if (this.webrtc) {
                                this.webrtc.send({
                                    type: 'gameOver',
                                    winner: this.physics.scoreL > this.physics.scoreR ? 'host' : 'guest'
                                });
                            }
                            return;
                        }
                    }

                    // Send state to guest at high frequency
                    if (now - this.lastNetworkUpdate >= NETWORK_DT && this.webrtc) {
                        const state = this.physics.getState();
                        this.webrtc.send({
                            type: 'state',
                            ...state,
                            timestamp: now
                        });
                        this.lastNetworkUpdate = now;
                    }

                    // Update render state
                    this.renderState.pL = this.physics.pL;
                    this.renderState.pR = this.physics.pR;
                    this.renderState.bx = this.physics.bx;
                    this.renderState.by = this.physics.by;
                    this.renderState.scoreL = this.physics.scoreL;
                    this.renderState.scoreR = this.physics.scoreR;

                } else {
                    // Guest: Use prediction + server reconciliation
                    this.prediction.predict(dt / 1000);
                    
                    // Send paddle position
                    if (now - this.lastNetworkUpdate >= NETWORK_DT && this.webrtc) {
                        this.webrtc.send({
                            type: 'paddle',
                            y: this.inputY
                        });
                        this.lastNetworkUpdate = now;
                    }

                    // Update render state
                    this.renderState.pR = this.inputY;
                    this.renderState.bx = this.prediction.bx;
                    this.renderState.by = this.prediction.by;
                }

                this.updateLatencyDisplay();
            }

            render() {
                // Update paddle positions
                this.gfxL.y = this.renderState.pL;
                this.gfxR.y = this.renderState.pR;

                // Update ball position with trail
                const oldX = this.ball.x;
                const oldY = this.ball.y;
                this.ball.x = this.renderState.bx;
                this.ball.y = this.renderState.by;

                // Draw trail
                this.ballTrail.clear();
                this.ballTrail.lineStyle(BALL_RADIUS * 1.5, 0xffffff, 0.15);
                this.ballTrail.moveTo(oldX, oldY);
                this.ballTrail.lineTo(this.ball.x, this.ball.y);

                // Update score
                this.updateScoreDisplay();
            }

            async host() {
                this.state.playerName = await this.getPlayerName();
                const btn = document.getElementById('btnHost');
                if(btn.disabled) return;
                btn.disabled = true;
                
                let code, attempts = 0;
                while(attempts < 10) {
                    code = Math.floor(1000 + Math.random() * 9000).toString();
                    try {
                        const exists = await get(ref(db, 'rooms/' + code));
                        if(!exists.exists()) break;
                    } catch(e) { break; }
                    attempts++;
                }
                
                if(attempts >= 10) {
                    this.showError('Failed to create room');
                    btn.disabled = false;
                    return;
                }

                this.state.room = code;
                this.state.role = 'host';
                
                document.getElementById('lobbyMain').classList.add('hidden');
                document.getElementById('lobbyWait').classList.remove('hidden');
                document.getElementById('codeDisp').innerText = code;

                try {
                    // Create room in Firebase (for signaling only)
                    await set(ref(db, 'rooms/' + code), { 
                        host: this.state.playerName,
                        status: 'waiting',
                        created: Date.now()
                    });

                    // Initialize WebRTC
                    this.webrtc = new WebRTCManager(
                        true,
                        (data) => this.onWebRTCMessage(data),
                        (status) => this.updateConnectionStatus(status)
                    );
                    
                    await this.webrtc.init(code);

                    // Wait for guest to join
                    const guestRef = ref(db, `rooms/${code}/guest`);
                    onValue(guestRef, (snap) => {
                        const guest = snap.val();
                        if (guest && !this.state.playing) {
                            this.state.opponentName = guest;
                            this.startOnlineGame();
                        }
                    });

                } catch(error) {
                    console.error('Host error:', error);
                    this.showError('Failed to create room');
                    this.cancelHosting();
                }
            }

            async join() {
                this.state.playerName = await this.getPlayerName();
                const codeInput = document.getElementById('codeIn');
                const code = codeInput.value.trim();
                const fb = document.getElementById('joinFeedback');
                const btn = document.getElementById('btnJoin');

                if(!code || !/^\d{4}$/.test(code)) {
                    fb.textContent = 'Enter valid 4-digit code';
                    return;
                }

                if(btn.disabled) return;
                btn.disabled = true;
                fb.textContent = 'Connecting...';

                try {
                    const roomRef = ref(db, 'rooms/' + code);
                    const snap = await get(roomRef);

                    if(!snap.exists()) {
                        fb.textContent = 'Room not found';
                        btn.disabled = false;
                        return;
                    }

                    const roomData = snap.val();
                    
                    if(roomData.guest || roomData.status !== 'waiting') {
                        fb.textContent = 'Room is full';
                        btn.disabled = false;
                        return;
                    }

                    this.state.room = code;
                    this.state.role = 'guest';
                    this.state.opponentName = roomData.host || 'Host';

                    // Join room
                    await update(roomRef, { 
                        guest: this.state.playerName,
                        status: 'playing'
                    });

                    // Initialize WebRTC
                    this.webrtc = new WebRTCManager(
                        false,
                        (data) => this.onWebRTCMessage(data),
                        (status) => this.updateConnectionStatus(status)
                    );
                    
                    await this.webrtc.init(code);

                    this.startOnlineGame();

                } catch(error) {
                    console.error('Join error:', error);
                    fb.textContent = 'Connection failed';
                    btn.disabled = false;
                    this.showError('Failed to join');
                }
            }

            startOnlineGame() {
                this.state.mode = 'online';
                this.state.playing = true;
                this.gameStopped = false;
                
                this.physics.scoreL = 0;
                this.physics.scoreR = 0;
                this.physics.reset();
                
                if (this.state.role === 'guest') {
                    const state = this.physics.getState();
                    this.prediction.hardSet(state.bx, state.by, state.bvx, state.bvy);
                }
                
                this.updateScoreDisplay();
                this.updatePlayerLabels();
                this.updateConnectionStatus('connecting');
                
                document.getElementById('lobbyScreen').classList.add('hidden');
                document.getElementById('lobbyWait').classList.add('hidden');
                document.getElementById('gameHud').classList.remove('hidden');
            }

            onWebRTCMessage(data) {
                if (this.state.role === 'host') {
                    // Host receives paddle position from guest
                    if (data.type === 'paddle') {
                        this.physics.pR = Math.max(PADDLE_MIN_Y, Math.min(PADDLE_MAX_Y, data.y));
                    }
                } else {
                    // Guest receives game state from host
                    if (data.type === 'state') {
                        this.prediction.updateTarget(data.bx, data.by, data.bvx, data.bvy);
                        this.renderState.pL = data.pL;
                        this.renderState.scoreL = data.scoreL;
                        this.renderState.scoreR = data.scoreR;
                    } else if (data.type === 'gameOver') {
                        const winner = data.winner === 'guest' ? "YOU WIN!" : "YOU LOST!";
                        this.stopGame(winner);
                    }
                }
            }

            showError(message) {
                const errorEl = document.getElementById('connectionError');
                errorEl.textContent = message;
                errorEl.classList.remove('hidden');
                setTimeout(() => errorEl.classList.add('hidden'), 5000);
            }
        }

        window.addEventListener('load', () => {
            try {
                new PongGame();
            } catch(error) {
                console.error('Fatal:', error);
                alert('Failed to start game. Please refresh.');
            }
        });
    </script>
</body>
</html>
