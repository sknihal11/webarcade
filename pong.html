<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Pong - WebRTC Edition (Secure)</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; user-select: none; -webkit-tap-highlight-color: transparent; }
        body { background-color: #000; overflow: hidden; width: 100vw; height: 100vh; font-family: "Courier New", Courier, monospace; display: flex; justify-content: center; align-items: center; }
        canvas { display: block; box-shadow: 0 0 50px rgba(0, 255, 255, 0.2); background: #050505; }
        
        .touch-zone { 
            position: absolute; 
            top: 0; bottom: 0; width: 50%; 
            z-index: 5; pointer-events: auto;
            transition: background 0.3s;
        }
        .touch-zone.active { background: rgba(255,255,255,0.05); }
        #leftZone { left: 0; }
        #rightZone { right: 0; }
        
        .touch-indicator {
            position: absolute; width: 60px; height: 60px;
            border: 3px solid rgba(255,255,255,0.6);
            border-radius: 50%; pointer-events: none;
            transform: translate(-50%, -50%);
            opacity: 0; transition: opacity 0.2s;
            z-index: 6;
        }
        .touch-indicator.visible { opacity: 1; }

        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 20; display: flex; flex-direction: column; align-items: center; }
        .interactive { pointer-events: auto; }
        .hud { width: 100%; padding: 20px 16px; display: flex; flex-direction: column; align-items: center; pointer-events: none; }
        
        .score-row { 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            width: 100%; 
            margin-top: 60px;
        }
        .score-box { 
            display: flex; 
            gap: clamp(40px, 12vw, 60px); 
            font-size: clamp(36px, 11vw, 60px); 
            font-weight: bold; 
            text-shadow: 0 0 10px currentColor; 
        }
        .player-info { 
            display: flex; 
            justify-content: space-between; 
            width: 100%; 
            max-width: 500px; 
            margin-top: 8px; 
            font-weight: bold; 
            letter-spacing: 2px; 
            font-size: clamp(10px, 2.8vw, 14px); 
            padding: 0 10px;
        }
        .label-l { color: #ff0055; text-shadow: 0 0 5px #ff0055; }
        .label-r { color: #00f3ff; text-shadow: 0 0 5px #00f3ff; }
        
        .screen { position: absolute; inset: 0; background: rgba(0,0,0,0.95); backdrop-filter: blur(4px); display: flex; flex-direction: column; align-items: center; justify-content: center; transition: opacity 0.3s; padding: 20px; overflow-y: auto; pointer-events: auto; }
        .hidden { opacity: 0; pointer-events: none; }
        h1 { color: #fff; font-size: clamp(24px, 7vw, 50px); margin-bottom: clamp(12px, 3vh, 30px); letter-spacing: clamp(2px, 1vw, 5px); text-shadow: 0 0 20px #00f3ff; text-transform: uppercase; text-align: center; }
        h2 { font-size: clamp(36px, 10vw, 60px); }
        button { background: rgba(0,0,0,0.6); border: 2px solid #fff; color: #fff; padding: clamp(8px, 2vh, 15px) clamp(16px, 5vw, 40px); margin: clamp(4px, 1vh, 10px); font-size: clamp(12px, 3.2vw, 18px); font-weight: bold; letter-spacing: 2px; text-transform: uppercase; cursor: pointer; box-shadow: 0 0 10px rgba(255,255,255,0.1); transition: all 0.2s; min-width: clamp(130px, 40vw, 200px); }
        button:active { transform: scale(0.95); background: #222; }
        button:disabled { opacity: 0.5; cursor: not-allowed; transform: none !important; }
        .btn-cyan { border-color: #00f3ff; color: #00f3ff; text-shadow: 0 0 5px #00f3ff; box-shadow: 0 0 10px rgba(0, 243, 255, 0.3); }
        .btn-pink { border-color: #ff0055; color: #ff0055; text-shadow: 0 0 5px #ff0055; box-shadow: 0 0 10px rgba(255, 0, 85, 0.3); }
        .btn-exit { position: absolute; top: 12px; left: 12px; border-color: #ff3333; color: #ff3333; padding: clamp(6px, 1.5vh, 10px) clamp(10px, 3vw, 20px); min-width: auto; font-size: clamp(10px, 2.8vw, 14px); box-shadow: 0 0 5px rgba(255, 50, 50, 0.5); z-index: 100; pointer-events: auto; }
        input { background: transparent; border: none; border-bottom: 2px solid #00f3ff; color: #fff; font-size: clamp(20px, 6vw, 30px); text-align: center; letter-spacing: 5px; width: clamp(120px, 45vw, 200px); margin: clamp(8px, 2vh, 20px); outline: none; padding: clamp(6px, 1.5vh, 10px); }
        input::-webkit-outer-spin-button, input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        input[type=number] { -moz-appearance: textfield; }
        .lobby-divider { color: #666; margin: clamp(4px, 1vh, 10px) 0; font-size: clamp(11px, 3vw, 16px); }
        .btn-back { font-size: clamp(10px, 2.5vw, 12px) !important; min-width: clamp(80px, 25vw, 100px) !important; border-color: #555 !important; color: #aaa !important; margin-top: clamp(6px, 1.5vh, 8px); }
        .feedback-text { color: #ff3333; font-size: clamp(10px, 2.8vw, 13px); min-height: 1.4em; margin-top: 4px; letter-spacing: 1px; text-transform: uppercase; }
        .room-code-label { color: #aaa; font-size: clamp(11px, 3vw, 16px); }
        .room-code-display { color: #0f0; font-size: clamp(36px, 10vw, 60px); margin: 6px 0; text-shadow: 0 0 20px #0f0; }
        .waiting-text { color: #fff; margin-top: clamp(8px, 2vh, 20px); font-size: clamp(12px, 3.2vw, 16px); }
        .error-notice { color: #ff6b6b; background: rgba(255, 0, 0, 0.1); border: 1px solid #ff3333; padding: 10px 15px; border-radius: 8px; margin-top: 10px; font-size: clamp(10px, 2.5vw, 12px); max-width: 90%; text-align: center; z-index: 1000; position: relative; }
        .back-btn-link { position: absolute; top: 12px; right: 12px; background: rgba(0,0,0,0.6); border: 2px solid #555; color: #aaa; padding: clamp(6px, 1.5vh, 10px) clamp(10px, 3vw, 20px); text-decoration: none; font-weight: bold; font-size: clamp(10px, 2.8vw, 14px); border-radius: 4px; text-transform: uppercase; z-index: 100; display: inline-block; }
        .back-btn-link:hover { background: rgba(50,50,50,0.8); }
        
        .connection-status {
            position: absolute; top: 50px; right: 12px;
            background: rgba(0,0,0,0.8); border: 2px solid;
            padding: 6px 12px; border-radius: 8px;
            font-size: 11px; font-weight: bold;
            z-index: 101; display: none;
        }
        .connection-status.connected { border-color: #0f0; color: #0f0; }
        .connection-status.disconnected { border-color: #f00; color: #f00; }
        .connection-status.connecting { border-color: #ff0; color: #ff0; }

        .latency-display {
            position: absolute; top: 90px; right: 12px;
            background: rgba(0,0,0,0.8); border: 2px solid #00f3ff;
            padding: 6px 12px; border-radius: 8px;
            font-size: 11px; font-weight: bold;
            color: #00f3ff;
            z-index: 101; display: none;
        }

        .round-countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid #00f3ff;
            border-radius: 15px;
            padding: 30px 50px;
            text-align: center;
            z-index: 50;
            display: none;
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.5);
        }
        .round-countdown.visible { display: block; }
        .round-countdown .countdown-number {
            font-size: clamp(60px, 15vw, 100px);
            color: #00f3ff;
            text-shadow: 0 0 20px #00f3ff;
            font-weight: bold;
            margin-bottom: 15px;
        }
        .round-countdown .countdown-text {
            font-size: clamp(16px, 4vw, 24px);
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        .loading-spinner {
            border: 3px solid rgba(0, 243, 255, 0.2);
            border-top: 3px solid #00f3ff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 10px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="leftZone" class="touch-zone"></div>
    <div id="rightZone" class="touch-zone"></div>
    <div id="touchIndicator" class="touch-indicator"></div>

    <div class="ui-layer">
        <div class="hud hidden" id="gameHud">
            <button class="btn-exit interactive" id="btnExit">EXIT</button>
            <a href="blog.html" class="back-btn-link">← DASH</a>
            <div id="connectionStatus" class="connection-status"></div>
            <div id="latencyDisplay" class="latency-display">RTT: --ms</div>
            <div class="score-row">
                <div class="score-box">
                    <div style="color:#ff0055" id="scoreL">0</div>
                    <div style="color:#00f3ff" id="scoreR">0</div>
                </div>
            </div>
            <div class="player-info">
                <span class="label-l" id="labelL">PLAYER 1</span>
                <span class="label-r" id="labelR">PLAYER 2</span>
            </div>
        </div>

        <div class="round-countdown" id="roundCountdown">
            <div class="countdown-number" id="countdownNumber">3</div>
            <div class="countdown-text" id="countdownText">GET READY</div>
        </div>

        <div id="menuScreen" class="screen interactive">
            <h1>NEON PONG</h1>
            <button class="btn-cyan" id="btnAI">SINGLE PLAYER</button>
            <button class="btn-pink" id="btnOnline">MULTIPLAYER</button>
            <a href="blog.html" class="btn-back" style="text-decoration:none; display:inline-block;">← DASHBOARD</a>
            <div id="connectionError" class="error-notice hidden"></div>
        </div>

        <div id="lobbyScreen" class="screen hidden interactive">
            <h1>LOBBY</h1>
            <div id="lobbyMain" style="text-align:center; display:flex; flex-direction:column; align-items:center;">
                <button id="btnHost" class="btn-cyan">CREATE ROOM</button>
                <div class="lobby-divider">--- OR JOIN ---</div>
                <input type="text" id="codeIn" placeholder="CODE" inputmode="numeric" maxlength="4" pattern="[0-9]*" autocomplete="off">
                <div class="feedback-text" id="joinFeedback"></div>
                <button id="btnJoin" class="btn-pink">JOIN GAME</button>
                <button id="btnBack" class="btn-back">BACK</button>
            </div>
            
            <div id="lobbyWait" class="hidden" style="text-align:center; display:flex; flex-direction:column; align-items:center;">
                <p class="room-code-label">ROOM CODE:</p>
                <h2 class="room-code-display" id="codeDisp">----</h2>
                <p class="waiting-text">Waiting for opponent...</p>
                <button id="btnCancelHost" class="btn-back" style="margin-top: 20px;">CANCEL</button>
            </div>
        </div>

        <div id="overScreen" class="screen hidden interactive">
            <h1 id="winMsg">WINNER</h1>
            <button class="btn-cyan" onclick="window.location.reload()">PLAY AGAIN</button>
            <a href="blog.html" class="btn-back" style="text-decoration:none; display:inline-block;">← DASHBOARD</a>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.3/pixi.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pixi-filters@5.3.0/dist/browser/pixi-filters.min.js"></script>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
        import { getDatabase, ref, set, onValue, update, remove, get, onDisconnect, off } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";
        import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";

        const firebaseConfig = {
            apiKey: "AIzaSyCzomf89xZhgcPsfYXKsYspCt-CiUVzjBA",
            authDomain: "webarcade-d4c3d.firebaseapp.com",
            databaseURL: "https://webarcade-d4c3d-default-rtdb.firebaseio.com",
            projectId: "webarcade-d4c3d",
            storageBucket: "webarcade-d4c3d.firebasestorage.app",
            messagingSenderId: "918209461327",
            appId: "1:918209461327:web:bd9c1a2431f9b5c66ffe3a"
        };

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);
        const auth = getAuth(app);

        // Game Constants - LOCKED to prevent tampering
        const W = 800, H = 600;
        const BALL_RADIUS = 8, PADDLE_WIDTH = 16, PADDLE_HEIGHT = 100;
        const BALL_BASE_SPEED_X = 420, BALL_MAX_SPEED = 850, BALL_ACCEL_FACTOR = 1.07;
        const PADDLE_MIN_Y = PADDLE_HEIGHT/2 + 10, PADDLE_MAX_Y = H - PADDLE_HEIGHT/2 - 10;
        const WIN_SCORE = 10;
        const PHYSICS_HZ = 120;
        const NETWORK_HZ = 30; // Reduced for mobile reliability
        const PHYSICS_DT = 1000 / PHYSICS_HZ;
        const NETWORK_DT = 1000 / NETWORK_HZ;
        const ROUND_COOLDOWN = 3;
        const MAX_DELTA = 100; // Cap delta time to prevent cheating
        const PADDLE_SPEED_LIMIT = 800; // Max paddle movement speed (pixels/sec)

        // WebRTC Configuration with TURN fallback
        const ICE_SERVERS = [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' },
            { urls: 'stun:stun2.l.google.com:19302' },
            { urls: 'stun:stun3.l.google.com:19302' },
            { urls: 'stun:stun4.l.google.com:19302' }
        ];

        // Utility: Sanitize input
        function sanitize(value, min, max) {
            if (typeof value !== 'number' || isNaN(value) || !isFinite(value)) {
                return (min + max) / 2;
            }
            return Math.max(min, Math.min(max, value));
        }

        // Utility: XSS protection
        function escapeHTML(str) {
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        // Physics Engine - Server-Authoritative (Host Only)
        class PhysicsEngine {
            constructor() {
                this.bx = W / 2;
                this.by = H / 2;
                this.bvx = 0;
                this.bvy = 0;
                this.pL = H / 2;
                this.pR = H / 2;
                this.scoreL = 0;
                this.scoreR = 0;
                this.lastHitTimeL = 0;
                this.lastHitTimeR = 0;
                this.accumulator = 0;
                this.ballActive = true;
                this.lastPaddleLUpdate = Date.now();
                this.lastPaddleRUpdate = Date.now();
            }

            reset(dir) {
                this.bx = W / 2;
                this.by = H / 2;
                const d = dir || (Math.random() > 0.5 ? 1 : -1);
                this.bvx = d * BALL_BASE_SPEED_X;
                this.bvy = (Math.random() * 70 + 70) * (Math.random() > 0.5 ? 1 : -1);
                this.ballActive = true;
            }

            freeze() {
                this.ballActive = false;
                this.bx = W / 2;
                this.by = H / 2;
                this.bvx = 0;
                this.bvy = 0;
            }

            // Anti-cheat: Validate paddle movement
            updatePaddle(side, targetY) {
                const now = Date.now();
                const lastUpdate = side === 'L' ? this.lastPaddleLUpdate : this.lastPaddleRUpdate;
                const dt = (now - lastUpdate) / 1000;
                const currentY = side === 'L' ? this.pL : this.pR;
                
                // Validate input
                targetY = sanitize(targetY, PADDLE_MIN_Y, PADDLE_MAX_Y);
                
                // Check speed limit
                const maxMove = PADDLE_SPEED_LIMIT * dt;
                const actualMove = Math.abs(targetY - currentY);
                
                if (actualMove > maxMove && dt > 0) {
                    // Movement too fast - interpolate
                    const direction = Math.sign(targetY - currentY);
                    targetY = currentY + direction * maxMove;
                }
                
                if (side === 'L') {
                    this.pL = targetY;
                    this.lastPaddleLUpdate = now;
                } else {
                    this.pR = targetY;
                    this.lastPaddleRUpdate = now;
                }
            }

            update(dt) {
                if (!this.ballActive) return null;

                // Cap delta to prevent time manipulation
                dt = Math.min(dt, MAX_DELTA);

                this.accumulator += dt;
                
                let iterations = 0;
                const MAX_ITERATIONS = 5;
                
                while (this.accumulator >= PHYSICS_DT && iterations < MAX_ITERATIONS) {
                    const result = this.step(PHYSICS_DT / 1000);
                    this.accumulator -= PHYSICS_DT;
                    iterations++;
                    
                    if (result) return result;
                }
                
                // Prevent unbounded accumulation
                if (this.accumulator > PHYSICS_DT * 10) {
                    this.accumulator = 0;
                }

                return null;
            }

            step(dt) {
                // Ball movement
                this.bx += this.bvx * dt;
                this.by += this.bvy * dt;

                // Wall collisions
                if (this.by - BALL_RADIUS < 0) {
                    this.by = BALL_RADIUS;
                    this.bvy = Math.abs(this.bvy) * 0.98;
                } else if (this.by + BALL_RADIUS > H) {
                    this.by = H - BALL_RADIUS;
                    this.bvy = -Math.abs(this.bvy) * 0.98;
                }

                // Paddle collisions
                this.checkPaddleHit(this.pL, 30, 1);
                this.checkPaddleHit(this.pR, W - 30, -1);

                // Scoring
                if (this.bx + BALL_RADIUS < 0) {
                    this.scoreR++;
                    return 'scoreR';
                } else if (this.bx - BALL_RADIUS > W) {
                    this.scoreL++;
                    return 'scoreL';
                }

                return null;
            }

            checkPaddleHit(py, px, dir) {
                const now = Date.now();
                const cooldown = (dir === 1) ? this.lastHitTimeL : this.lastHitTimeR;
                if (now - cooldown < 80) return;

                const movingToward = (dir === 1 && this.bvx < 0) || (dir === -1 && this.bvx > 0);
                if (!movingToward) return;

                const closestX = Math.max(px - PADDLE_WIDTH/2, Math.min(this.bx, px + PADDLE_WIDTH/2));
                const closestY = Math.max(py - PADDLE_HEIGHT/2, Math.min(this.by, py + PADDLE_HEIGHT/2));
                const distSq = (this.bx - closestX) ** 2 + (this.by - closestY) ** 2;

                if (distSq <= BALL_RADIUS ** 2) {
                    if (dir === 1) this.lastHitTimeL = now;
                    else this.lastHitTimeR = now;

                    let newSpeed = Math.min(Math.abs(this.bvx) * BALL_ACCEL_FACTOR, BALL_MAX_SPEED);
                    this.bvx = newSpeed * dir;

                    const relativePos = (this.by - py) / (PADDLE_HEIGHT/2);
                    this.bvy = relativePos * newSpeed * 0.45;
                    this.bvy = Math.max(-newSpeed * 0.55, Math.min(newSpeed * 0.55, this.bvy));

                    const pushout = Math.max(BALL_RADIUS + PADDLE_WIDTH/2 + 5, Math.abs(this.bvx) * 0.03);
                    this.bx = (dir === 1) ? (px + pushout) : (px - pushout);
                    this.bx = Math.max(BALL_RADIUS + 5, Math.min(W - BALL_RADIUS - 5, this.bx));
                }
            }

            getState() {
                return {
                    bx: this.bx,
                    by: this.by,
                    bvx: this.bvx,
                    bvy: this.bvy,
                    pL: this.pL,
                    pR: this.pR,
                    scoreL: this.scoreL,
                    scoreR: this.scoreR,
                    ballActive: this.ballActive,
                    timestamp: Date.now()
                };
            }

            setState(state) {
                // Anti-cheat: Validate all state values
                this.bx = sanitize(state.bx, 0, W);
                this.by = sanitize(state.by, 0, H);
                this.bvx = sanitize(state.bvx, -BALL_MAX_SPEED, BALL_MAX_SPEED);
                this.bvy = sanitize(state.bvy, -BALL_MAX_SPEED, BALL_MAX_SPEED);
                this.pL = sanitize(state.pL, PADDLE_MIN_Y, PADDLE_MAX_Y);
                this.pR = sanitize(state.pR, PADDLE_MIN_Y, PADDLE_MAX_Y);
                this.scoreL = sanitize(state.scoreL, 0, WIN_SCORE);
                this.scoreR = sanitize(state.scoreR, 0, WIN_SCORE);
                if (state.ballActive !== undefined) {
                    this.ballActive = !!state.ballActive;
                }
            }
        }

        // Client-Side Prediction with Anti-Cheat
        class PredictionEngine {
            constructor() {
                this.bx = W / 2;
                this.by = H / 2;
                this.bvx = 0;
                this.bvy = 0;
                this.targetBx = W / 2;
                this.targetBy = H / 2;
                this.targetVx = 0;
                this.targetVy = 0;
                this.lerpFactor = 0.3; // Smoother interpolation
                this.ballActive = true;
                this.lastServerUpdate = 0;
            }

            predict(dt) {
                if (!this.ballActive) return;

                // Cap delta
                dt = Math.min(dt, MAX_DELTA / 1000);

                // Predict ball movement
                this.bx += this.bvx * dt;
                this.by += this.bvy * dt;

                // Wall bounces
                if (this.by - BALL_RADIUS < 0) {
                    this.by = BALL_RADIUS;
                    this.bvy = Math.abs(this.bvy) * 0.98;
                } else if (this.by + BALL_RADIUS > H) {
                    this.by = H - BALL_RADIUS;
                    this.bvy = -Math.abs(this.bvy) * 0.98;
                }

                // Smooth lerp to server state
                this.bx += (this.targetBx - this.bx) * this.lerpFactor;
                this.by += (this.targetBy - this.by) * this.lerpFactor;
                this.bvx += (this.targetVx - this.bvx) * this.lerpFactor;
                this.bvy += (this.targetVy - this.bvy) * this.lerpFactor;
            }

            updateTarget(bx, by, vx, vy, timestamp) {
                // Anti-cheat: Reject stale updates
                if (timestamp && timestamp < this.lastServerUpdate) {
                    return;
                }
                
                this.targetBx = sanitize(bx, 0, W);
                this.targetBy = sanitize(by, 0, H);
                this.targetVx = sanitize(vx, -BALL_MAX_SPEED, BALL_MAX_SPEED);
                this.targetVy = sanitize(vy, -BALL_MAX_SPEED, BALL_MAX_SPEED);
                this.lastServerUpdate = timestamp || Date.now();
            }

            hardSet(bx, by, vx, vy) {
                this.bx = this.targetBx = sanitize(bx, 0, W);
                this.by = this.targetBy = sanitize(by, 0, H);
                this.bvx = this.targetVx = sanitize(vx, -BALL_MAX_SPEED, BALL_MAX_SPEED);
                this.bvy = this.targetVy = sanitize(vy, -BALL_MAX_SPEED, BALL_MAX_SPEED);
            }

            freeze() {
                this.ballActive = false;
                this.bx = W / 2;
                this.by = H / 2;
                this.bvx = 0;
                this.bvy = 0;
                this.hardSet(W / 2, H / 2, 0, 0);
            }

            activate() {
                this.ballActive = true;
            }
        }

        // Enhanced WebRTC Manager with Security
        class WebRTCManager {
            constructor(isHost, onMessage, onConnectionChange) {
                this.isHost = isHost;
                this.onMessage = onMessage;
                this.onConnectionChange = onConnectionChange;
                this.pc = null;
                this.dataChannel = null;
                this.connected = false;
                this.signalRef = null;
                this.signalListener = null;
                this.iceRef = null;
                this.iceListener = null;
                this.connectionTimeout = null;
                this.gatheringTimeout = null;
                
                // Latency tracking
                this.lastPingTime = 0;
                this.rtt = 0;
                this.rttSamples = [];
                this.pingInterval = null;
                
                // Anti-cheat
                this.messageCount = 0;
                this.lastMessageTime = Date.now();
                this.messageRateLimit = 100; // Max messages per second
                
                // Cleanup tracking
                this.cleanupHandlers = [];
            }

            async init(roomCode) {
                try {
                    this.pc = new RTCPeerConnection({ 
                        iceServers: ICE_SERVERS,
                        iceCandidatePoolSize: 10
                    });

                    // Connection timeout
                    this.connectionTimeout = setTimeout(() => {
                        if (this.pc && this.pc.iceConnectionState !== 'connected' && this.pc.iceConnectionState !== 'completed') {
                            console.error('WebRTC connection timeout');
                            this.onConnectionChange('timeout');
                        }
                    }, 30000);

                    // ICE connection state (more reliable)
                    const iceStateHandler = () => {
                        const state = this.pc.iceConnectionState;
                        console.log('ICE state:', state);
                        
                        if (state === 'connected' || state === 'completed') {
                            this.connected = true;
                            if (this.connectionTimeout) {
                                clearTimeout(this.connectionTimeout);
                                this.connectionTimeout = null;
                            }
                            this.startPingMonitoring();
                            this.onConnectionChange('connected');
                        } else if (state === 'disconnected') {
                            this.connected = false;
                            this.onConnectionChange('disconnected');
                        } else if (state === 'failed') {
                            this.connected = false;
                            this.stopPingMonitoring();
                            this.onConnectionChange('failed');
                        }
                    };
                    
                    this.pc.addEventListener('iceconnectionstatechange', iceStateHandler);
                    this.cleanupHandlers.push(() => this.pc.removeEventListener('iceconnectionstatechange', iceStateHandler));

                    // Candidate queue for proper ordering
                    const candidateQueue = [];
                    let remoteDescSet = false;

                    // ICE candidate handling
                    const candidateHandler = async (event) => {
                        if (event.candidate) {
                            const path = this.isHost ? 'hostIce' : 'guestIce';
                            try {
                                const iceRef = ref(db, `rooms/${roomCode}/${path}`);
                                const snapshot = await get(iceRef);
                                const existing = snapshot.val() || [];
                                if (!Array.isArray(existing)) {
                                    await set(iceRef, []);
                                }
                                const current = await get(iceRef);
                                const arr = current.val() || [];
                                arr.push(JSON.stringify(event.candidate.toJSON()));
                                await set(iceRef, arr);
                            } catch (err) {
                                console.error('ICE candidate error:', err);
                            }
                        }
                    };
                    
                    this.pc.addEventListener('icecandidate', candidateHandler);
                    this.cleanupHandlers.push(() => this.pc.removeEventListener('icecandidate', candidateHandler));

                    if (this.isHost) {
                        // HOST: Create reliable data channel
                        this.dataChannel = this.pc.createDataChannel('gameData', {
                            ordered: true,
                            maxRetransmits: 3
                        });
                        this.setupDataChannel();

                        // Create offer
                        const offer = await this.pc.createOffer();
                        await this.pc.setLocalDescription(offer);

                        // Wait for ICE gathering
                        await this.waitForICEGathering();

                        await set(ref(db, `rooms/${roomCode}/offer`), JSON.stringify(this.pc.localDescription));

                        // Listen for answer
                        this.signalRef = ref(db, `rooms/${roomCode}/answer`);
                        this.signalListener = onValue(this.signalRef, async (snap) => {
                            const answer = snap.val();
                            if (answer && this.pc.signalingState !== 'stable') {
                                try {
                                    await this.pc.setRemoteDescription(new RTCSessionDescription(JSON.parse(answer)));
                                    remoteDescSet = true;
                                    for (const cand of candidateQueue) {
                                        await this.pc.addIceCandidate(cand);
                                    }
                                    candidateQueue.length = 0;
                                } catch (e) {
                                    console.error('Error setting remote description:', e);
                                }
                            }
                        });
                    } else {
                        // GUEST: Receive data channel
                        const dataChannelHandler = (event) => {
                            this.dataChannel = event.channel;
                            this.setupDataChannel();
                        };
                        
                        this.pc.addEventListener('datachannel', dataChannelHandler);
                        this.cleanupHandlers.push(() => this.pc.removeEventListener('datachannel', dataChannelHandler));

                        // Wait for offer
                        this.signalRef = ref(db, `rooms/${roomCode}/offer`);
                        this.signalListener = onValue(this.signalRef, async (snap) => {
                            const offer = snap.val();
                            if (offer && this.pc.signalingState === 'stable') {
                                try {
                                    await this.pc.setRemoteDescription(new RTCSessionDescription(JSON.parse(offer)));
                                    remoteDescSet = true;
                                    
                                    const answer = await this.pc.createAnswer();
                                    await this.pc.setLocalDescription(answer);

                                    await this.waitForICEGathering();

                                    await set(ref(db, `rooms/${roomCode}/answer`), JSON.stringify(this.pc.localDescription));
                                    
                                    for (const cand of candidateQueue) {
                                        await this.pc.addIceCandidate(cand);
                                    }
                                    candidateQueue.length = 0;
                                } catch (e) {
                                    console.error('Error handling offer:', e);
                                }
                            }
                        });
                    }

                    // Listen for ICE candidates
                    const icePath = this.isHost ? 'guestIce' : 'hostIce';
                    this.iceRef = ref(db, `rooms/${roomCode}/${icePath}`);
                    this.iceListener = onValue(this.iceRef, async (snap) => {
                        const candidates = snap.val();
                        if (candidates && Array.isArray(candidates)) {
                            for (const candStr of candidates) {
                                try {
                                    const candidate = new RTCIceCandidate(JSON.parse(candStr));
                                    if (remoteDescSet && this.pc.remoteDescription) {
                                        await this.pc.addIceCandidate(candidate);
                                    } else {
                                        candidateQueue.push(candidate);
                                    }
                                } catch (e) {
                                    console.error('Error adding ICE candidate:', e);
                                }
                            }
                        }
                    });
                } catch (error) {
                    console.error('WebRTC init error:', error);
                    this.onConnectionChange('failed');
                }
            }

            async waitForICEGathering() {
                if (this.pc.iceGatheringState === 'complete') {
                    return;
                }

                return new Promise((resolve) => {
                    const checkGathering = () => {
                        if (this.pc.iceGatheringState === 'complete') {
                            this.pc.removeEventListener('icegatheringstatechange', checkGathering);
                            if (this.gatheringTimeout) {
                                clearTimeout(this.gatheringTimeout);
                                this.gatheringTimeout = null;
                            }
                            resolve();
                        }
                    };
                    
                    this.pc.addEventListener('icegatheringstatechange', checkGathering);
                    
                    // Fallback timeout
                    this.gatheringTimeout = setTimeout(() => {
                        this.pc.removeEventListener('icegatheringstatechange', checkGathering);
                        resolve();
                    }, 3000);
                });
            }

            setupDataChannel() {
                const openHandler = () => {
                    this.connected = true;
                    this.onConnectionChange('connected');
                };
                
                const closeHandler = () => {
                    this.connected = false;
                    this.onConnectionChange('disconnected');
                };
                
                const errorHandler = (error) => {
                    console.error('Data channel error:', error);
                };
                
                const messageHandler = (event) => {
                    try {
                        // Anti-cheat: Rate limiting
                        const now = Date.now();
                        if (now - this.lastMessageTime > 1000) {
                            this.messageCount = 0;
                            this.lastMessageTime = now;
                        }
                        
                        this.messageCount++;
                        if (this.messageCount > this.messageRateLimit) {
                            console.warn('Message rate limit exceeded');
                            return;
                        }
                        
                        const data = JSON.parse(event.data);
                        
                        // Handle ping/pong
                        if (data.type === 'ping') {
                            this.send({ type: 'pong', timestamp: data.timestamp });
                            return;
                        } else if (data.type === 'pong') {
                            const rtt = Date.now() - data.timestamp;
                            this.rttSamples.push(rtt);
                            if (this.rttSamples.length > 10) {
                                this.rttSamples.shift();
                            }
                            // Smoothed RTT
                            this.rtt = Math.round(this.rttSamples.reduce((a, b) => a + b) / this.rttSamples.length);
                            return;
                        }
                        
                        this.onMessage(data);
                    } catch (e) {
                        console.error('Error parsing message:', e);
                    }
                };

                this.dataChannel.addEventListener('open', openHandler);
                this.dataChannel.addEventListener('close', closeHandler);
                this.dataChannel.addEventListener('error', errorHandler);
                this.dataChannel.addEventListener('message', messageHandler);
                
                this.cleanupHandlers.push(() => {
                    if (this.dataChannel) {
                        this.dataChannel.removeEventListener('open', openHandler);
                        this.dataChannel.removeEventListener('close', closeHandler);
                        this.dataChannel.removeEventListener('error', errorHandler);
                        this.dataChannel.removeEventListener('message', messageHandler);
                    }
                });
            }

            send(data) {
                if (this.dataChannel && this.dataChannel.readyState === 'open') {
                    try {
                        this.dataChannel.send(JSON.stringify(data));
                    } catch (e) {
                        console.error('Send error:', e);
                    }
                }
            }

            startPingMonitoring() {
                this.pingInterval = setInterval(() => {
                    if (this.connected) {
                        this.send({ type: 'ping', timestamp: Date.now() });
                    }
                }, 1000);
            }

            stopPingMonitoring() {
                if (this.pingInterval) {
                    clearInterval(this.pingInterval);
                    this.pingInterval = null;
                }
            }

            async cleanup() {
                this.stopPingMonitoring();
                
                if (this.connectionTimeout) {
                    clearTimeout(this.connectionTimeout);
                    this.connectionTimeout = null;
                }
                
                if (this.gatheringTimeout) {
                    clearTimeout(this.gatheringTimeout);
                    this.gatheringTimeout = null;
                }
                
                // Remove all event listeners
                this.cleanupHandlers.forEach(fn => fn());
                this.cleanupHandlers = [];
                
                if (this.signalListener && this.signalRef) {
                    off(this.signalRef);
                    this.signalListener = null;
                    this.signalRef = null;
                }
                
                if (this.iceListener && this.iceRef) {
                    off(this.iceRef);
                    this.iceListener = null;
                    this.iceRef = null;
                }
                
                if (this.dataChannel) {
                    this.dataChannel.close();
                    this.dataChannel = null;
                }
                
                if (this.pc) {
                    this.pc.close();
                    this.pc = null;
                }
                
                this.connected = false;
            }
        }

        // Main Game Class with All Fixes
        class PongGame {
            constructor() {
                const oldCanvas = document.querySelector('canvas');
                if(oldCanvas) oldCanvas.remove();

                this.app = new PIXI.Application({
                    width: W, height: H, backgroundColor: 0x050505,
                    resolution: window.devicePixelRatio || 1,
                    autoDensity: true, antialias: true
                });
                
                document.body.appendChild(this.app.view);
                
                this.state = {
                    playing: false, 
                    mode: '', 
                    role: '', 
                    room: null,
                    playerName: '', 
                    opponentName: ''
                };
                
                this.inputY = H/2;
                this.scaleFactor = 1;
                this.eventCleanup = [];
                this.authReady = false;
                this.currentUser = null;
                this.gameStopped = false;
                this.isCleaningUp = false;

                // Physics engines
                this.physics = new PhysicsEngine();
                this.prediction = new PredictionEngine();
                
                // WebRTC
                this.webrtc = null;
                this.lastNetworkUpdate = 0;

                // Firebase listeners
                this.guestRef = null;
                this.guestListener = null;
                this.roomDisconnectRef = null;

                // Round countdown
                this.countdownActive = false;
                this.countdownValue = 0;
                this.countdownInterval = null;

                // Rendering state
                this.renderState = {
                    pL: H/2,
                    pR: H/2,
                    bx: W/2,
                    by: H/2,
                    scoreL: 0,
                    scoreR: 0
                };

                this.initGFX();
                this.initAuth();
                this.initUI();
                this.initInput();
                this.resize();
                
                const resizeHandler = () => this.resize();
                window.addEventListener('resize', resizeHandler);
                this.eventCleanup.push(() => window.removeEventListener('resize', resizeHandler));
                
                // Page visibility handling
                const visibilityHandler = () => {
                    if (document.hidden && this.state.playing) {
                        this.handleVisibilityLoss();
                    }
                };
                document.addEventListener('visibilitychange', visibilityHandler);
                this.eventCleanup.push(() => document.removeEventListener('visibilitychange', visibilityHandler));
                
                // Beforeunload cleanup
                const unloadHandler = (e) => {
                    if (this.state.playing) {
                        this.cleanup();
                    }
                };
                window.addEventListener('beforeunload', unloadHandler);
                this.eventCleanup.push(() => window.removeEventListener('beforeunload', unloadHandler));
                
                this.app.ticker.add((delta) => this.loop(delta));
            }

            handleVisibilityLoss() {
                // Pause game if window loses focus in online mode
                if (this.state.mode === 'online') {
                    console.log('Tab hidden - pausing may affect gameplay');
                }
            }

            initAuth() {
                onAuthStateChanged(auth, (user) => {
                    this.currentUser = user;
                    this.authReady = true;
                    
                    if (!user) {
                        console.warn('No user logged in - username will default to "Player"');
                    }
                });
            }

            resize() {
                const scale = Math.min(window.innerWidth / W, window.innerHeight / H);
                this.app.view.style.width  = `${W * scale}px`;
                this.app.view.style.height = `${H * scale}px`;
                this.scaleFactor = scale;
            }

            initGFX() {
                try {
                    if(PIXI.filters?.BloomFilter) {
                        const quality = window.devicePixelRatio > 1 ? 2 : 3;
                        const bloom = new PIXI.filters.BloomFilter({strength: 0.3, quality, blur: 6});
                        this.app.stage.filters = [bloom];
                        this.eventCleanup.push(() => {
                            bloom.destroy();
                        });
                    }
                } catch(e) {}
                
                const net = new PIXI.Graphics();
                net.beginFill(0x333333);
                for(let y = 10; y < H; y += 30) net.drawRect(W/2 - 1, y, 2, 15);
                net.endFill();
                this.app.stage.addChild(net);

                const makePad = (c, x) => {
                    const g = new PIXI.Graphics();
                    g.beginFill(c);
                    g.drawRoundedRect(-PADDLE_WIDTH/2, -PADDLE_HEIGHT/2, PADDLE_WIDTH, PADDLE_HEIGHT, 4);
                    g.endFill();
                    g.beginFill(0xffffff, 0.3);
                    g.drawRoundedRect(-PADDLE_WIDTH/2 + 2, -PADDLE_HEIGHT/2 + 2, PADDLE_WIDTH - 4, PADDLE_HEIGHT - 4, 3);
                    g.endFill();
                    g.x = x; g.y = H/2;
                    this.app.stage.addChild(g);
                    return g;
                };
                this.gfxL = makePad(0xff0055, 30);
                this.gfxR = makePad(0x00f3ff, W - 30);

                this.ball = new PIXI.Graphics();
                this.ball.beginFill(0xffffff);
                this.ball.drawCircle(0, 0, BALL_RADIUS);
                this.ball.endFill();
                this.ball.x = W/2; this.ball.y = H/2;
                this.app.stage.addChild(this.ball);
                
                this.ballTrail = new PIXI.Graphics();
                this.app.stage.addChildAt(this.ballTrail, 1);
            }

            initInput() {
                const touchIndicator = document.getElementById('touchIndicator');
                let touchActive = false;
                
                const onInput = (clientY, show = false) => {
                    if(!this.state.playing) return;
                    const rect = this.app.view.getBoundingClientRect();
                    let relativeY = (clientY - rect.top) / this.scaleFactor;
                    this.inputY = Math.max(PADDLE_MIN_Y, Math.min(PADDLE_MAX_Y, relativeY));
                    
                    if(show) {
                        const canvasCenterX = rect.left + (rect.width * 0.5);
                        touchIndicator.style.left = canvasCenterX + 'px';
                        touchIndicator.style.top = clientY + 'px';
                        touchIndicator.classList.add('visible');
                        touchActive = true;
                    }
                };

                const mouseMoveHandler = (e) => onInput(e.clientY);
                window.addEventListener('mousemove', mouseMoveHandler);
                this.eventCleanup.push(() => window.removeEventListener('mousemove', mouseMoveHandler));

                const zones = document.querySelectorAll('.touch-zone');
                zones.forEach(z => {
                    const handlers = {
                        start: (e) => {
                            e.preventDefault();
                            z.classList.add('active');
                            for(let i = 0; i < e.touches.length; i++) {
                                onInput(e.touches[i].clientY, true);
                            }
                        },
                        move: (e) => {
                            e.preventDefault();
                            if(e.touches.length > 0) onInput(e.touches[0].clientY, true);
                        },
                        end: (e) => {
                            e.preventDefault();
                            z.classList.remove('active');
                            touchIndicator.classList.remove('visible');
                            touchActive = false;
                        }
                    };
                    
                    z.addEventListener('touchstart', handlers.start, { passive: false });
                    z.addEventListener('touchmove', handlers.move, { passive: false });
                    z.addEventListener('touchend', handlers.end, { passive: false });
                    z.addEventListener('touchcancel', handlers.end, { passive: false });
                    
                    this.eventCleanup.push(() => {
                        z.removeEventListener('touchstart', handlers.start);
                        z.removeEventListener('touchmove', handlers.move);
                        z.removeEventListener('touchend', handlers.end);
                        z.removeEventListener('touchcancel', handlers.end);
                    });
                });
                
                const keyHandler = (e) => {
                    if(!this.state.playing) return;
                    if(e.key === 'ArrowUp') this.inputY = Math.max(PADDLE_MIN_Y, this.inputY - 20);
                    if(e.key === 'ArrowDown') this.inputY = Math.min(PADDLE_MAX_Y, this.inputY + 20);
                };
                window.addEventListener('keydown', keyHandler);
                this.eventCleanup.push(() => window.removeEventListener('keydown', keyHandler));
            }

            initUI() {
                const el = id => document.getElementById(id);
                
                // Prevent double-clicks
                let lastClick = 0;
                const clickGuard = (fn) => {
                    return () => {
                        const now = Date.now();
                        if (now - lastClick < 500) return;
                        lastClick = now;
                        fn();
                    };
                };
                
                el('btnAI').onclick = clickGuard(() => this.startAI());
                el('btnOnline').onclick = clickGuard(() => this.showLobby());
                el('btnBack').onclick = clickGuard(() => this.hideLobby());
                el('btnHost').onclick = clickGuard(() => this.host());
                el('btnJoin').onclick = clickGuard(() => this.join());
                el('btnExit').onclick = clickGuard(() => this.manualExit());
                el('btnCancelHost').onclick = clickGuard(() => this.cancelHosting());
                
                el('codeIn').addEventListener('keypress', (e) => {
                    if(e.key === 'Enter') { e.preventDefault(); this.join(); }
                });
                
                // Input validation
                el('codeIn').addEventListener('input', (e) => {
                    e.target.value = e.target.value.replace(/[^0-9]/g, '').slice(0, 4);
                });
            }

            async getPlayerName() {
                try {
                    if (!this.authReady) {
                        await new Promise(resolve => {
                            const check = () => {
                                if (this.authReady) resolve();
                                else setTimeout(check, 100);
                            };
                            check();
                        });
                    }
                    
                    if (this.currentUser) {
                        const userRef = ref(db, 'users/' + this.currentUser.uid + '/username');
                        const snap = await get(userRef);
                        if (snap.exists()) {
                            return escapeHTML(snap.val().substring(0, 20)); // Limit length
                        }
                    }
                } catch(e) {
                    console.error('Error fetching username:', e);
                }
                return 'Player';
            }

            updatePlayerLabels() {
                const labelL = document.getElementById('labelL');
                const labelR = document.getElementById('labelR');
                
                if(this.state.mode === 'ai') {
                    labelL.textContent = this.state.playerName.toUpperCase();
                    labelR.textContent = 'AI';
                } else if(this.state.mode === 'online') {
                    if(this.state.role === 'host') {
                        labelL.textContent = this.state.playerName.toUpperCase();
                        labelR.textContent = this.state.opponentName.toUpperCase();
                    } else {
                        labelL.textContent = this.state.opponentName.toUpperCase();
                        labelR.textContent = this.state.playerName.toUpperCase();
                    }
                }
            }

            showLobby() {
                document.getElementById('menuScreen').classList.add('hidden');
                document.getElementById('lobbyScreen').classList.remove('hidden');
            }

            hideLobby() {
                document.getElementById('lobbyScreen').classList.add('hidden');
                document.getElementById('menuScreen').classList.remove('hidden');
                document.getElementById('joinFeedback').textContent = '';
                ['btnJoin', 'btnHost'].forEach(id => document.getElementById(id).disabled = false);
            }

            async startAI() {
                this.state.playerName = await this.getPlayerName();
                this.state = {...this.state, mode: 'ai', playing: true};
                this.gameStopped = false;
                
                this.physics.scoreL = 0;
                this.physics.scoreR = 0;
                
                this.updateScoreDisplay();
                this.updatePlayerLabels();
                
                document.getElementById('menuScreen').classList.add('hidden');
                document.getElementById('gameHud').classList.remove('hidden');
                document.getElementById('connectionStatus').style.display = 'none';
                document.getElementById('latencyDisplay').style.display = 'none';

                this.startRoundCountdown(() => {
                    this.physics.reset();
                });
            }

            async manualExit() {
                await this.cleanup();
                window.location.reload();
            }

            async cancelHosting() {
                await this.cleanup();
                document.getElementById('lobbyWait').classList.add('hidden');
                document.getElementById('lobbyMain').classList.remove('hidden');
                ['btnJoin', 'btnHost'].forEach(id => document.getElementById(id).disabled = false);
            }

            async cleanup() {
                if(this.isCleaningUp) return;
                this.isCleaningUp = true;

                // Stop countdown
                if (this.countdownInterval) {
                    clearInterval(this.countdownInterval);
                    this.countdownInterval = null;
                }

                this.eventCleanup.forEach(fn => {
                    try { fn(); } catch(e) {}
                });
                this.eventCleanup = [];

                if (this.webrtc) {
                    await this.webrtc.cleanup();
                    this.webrtc = null;
                }

                if (this.guestListener && this.guestRef) {
                    off(this.guestRef);
                    this.guestListener = null;
                    this.guestRef = null;
                }

                if(this.state.room) {
                    const room = this.state.room;
                    this.state.room = null;
                    
                    try {
                        await remove(ref(db, 'rooms/' + room));
                    } catch(e) {}
                }
                
                // Clear graphics
                if (this.ballTrail) {
                    this.ballTrail.clear();
                }
                
                this.isCleaningUp = false;
            }

            stopGame(reason) {
                if(this.gameStopped) return;
                this.gameStopped = true;
                this.state.playing = false;
                
                if (this.countdownInterval) {
                    clearInterval(this.countdownInterval);
                    this.countdownInterval = null;
                }
                
                this.ballTrail.clear();
                document.getElementById('gameHud').classList.add('hidden');
                document.getElementById('roundCountdown').classList.remove('visible');
                document.getElementById('winMsg').innerText = reason || "GAME OVER";
                document.getElementById('overScreen').classList.remove('hidden');
                document.getElementById('connectionStatus').style.display = 'none';
                document.getElementById('latencyDisplay').style.display = 'none';
            }

            updateConnectionStatus(status) {
                const statusEl = document.getElementById('connectionStatus');
                const latencyEl = document.getElementById('latencyDisplay');
                
                if(this.state.mode === 'online' && this.state.playing) {
                    statusEl.style.display = 'block';
                    statusEl.className = 'connection-status';
                    
                    if (status === 'connected') {
                        statusEl.classList.add('connected');
                        statusEl.textContent = 'CONNECTED';
                        latencyEl.style.display = 'block';
                    } else if (status === 'connecting') {
                        statusEl.classList.add('connecting');
                        statusEl.textContent = 'CONNECTING...';
                        latencyEl.style.display = 'none';
                    } else if (status === 'timeout') {
                        this.stopGame('CONNECTION TIMEOUT');
                        this.cleanup();
                    } else {
                        statusEl.classList.add('disconnected');
                        statusEl.textContent = 'DISCONNECTED';
                        latencyEl.style.display = 'none';
                        
                        if (status === 'failed') {
                            setTimeout(() => {
                                this.stopGame('CONNECTION LOST');
                                this.cleanup();
                            }, 2000);
                        }
                    }
                } else {
                    statusEl.style.display = 'none';
                    latencyEl.style.display = 'none';
                }
            }

            updateLatencyDisplay() {
                if (this.webrtc && this.webrtc.rtt > 0) {
                    document.getElementById('latencyDisplay').textContent = `RTT: ${this.webrtc.rtt}ms`;
                }
            }

            updateScoreDisplay() {
                document.getElementById('scoreL').innerText = this.renderState.scoreL;
                document.getElementById('scoreR').innerText = this.renderState.scoreR;
            }

            startRoundCountdown(onComplete) {
                if (this.countdownActive) return;
                
                this.countdownActive = true;
                this.countdownValue = ROUND_COOLDOWN;
                
                const countdownEl = document.getElementById('roundCountdown');
                const numberEl = document.getElementById('countdownNumber');
                const textEl = document.getElementById('countdownText');
                
                countdownEl.classList.add('visible');
                textEl.textContent = 'GET READY';
                
                this.countdownInterval = setInterval(() => {
                    if (this.countdownValue > 0) {
                        numberEl.textContent = this.countdownValue;
                        this.countdownValue--;
                    } else {
                        numberEl.textContent = 'GO!';
                        textEl.textContent = '';
                        
                        setTimeout(() => {
                            countdownEl.classList.remove('visible');
                            this.countdownActive = false;
                            if (this.countdownInterval) {
                                clearInterval(this.countdownInterval);
                                this.countdownInterval = null;
                            }
                            if (onComplete) onComplete();
                        }, 500);
                        
                        if (this.countdownInterval) {
                            clearInterval(this.countdownInterval);
                            this.countdownInterval = null;
                        }
                    }
                }, 1000);
            }

            loop(delta) {
                if(!this.state.playing || this.countdownActive) return;
                
                const dt = this.app.ticker.elapsedMS;

                if(this.state.mode === 'ai') {
                    this.updateAI(dt);
                } else if(this.state.mode === 'online') {
                    this.updateOnline(dt);
                }

                this.render();
            }

            updateAI(dt) {
                // Update input
                this.physics.pL = this.inputY;

                // AI logic with difficulty scaling
                const aiBaseSpeed = 320;
                const aiSpeedBoost = Math.abs(this.physics.bvx) * 0.22;
                const aiSpeed = Math.min(500, aiBaseSpeed + aiSpeedBoost);
                const target = this.physics.bx > W / 2 ? this.physics.by : H / 2;
                const diff = target - this.physics.pR;
                const maxMove = aiSpeed * (dt / 1000);
                this.physics.pR = Math.abs(diff) <= maxMove ? target : this.physics.pR + Math.sign(diff) * maxMove;
                this.physics.pR = Math.max(PADDLE_MIN_Y, Math.min(PADDLE_MAX_Y, this.physics.pR));

                // Update physics
                const result = this.physics.update(dt);
                
                if (result) {
                    this.physics.freeze();
                    
                    if (this.physics.scoreL >= WIN_SCORE || this.physics.scoreR >= WIN_SCORE) {
                        const winner = this.physics.scoreL > this.physics.scoreR ? "YOU WIN!" : "YOU LOST!";
                        this.stopGame(winner);
                    } else {
                        this.startRoundCountdown(() => {
                            this.physics.reset(result === 'scoreL' ? -1 : 1);
                        });
                    }
                }

                // Update render state
                this.renderState.pL = this.physics.pL;
                this.renderState.pR = this.physics.pR;
                this.renderState.bx = this.physics.bx;
                this.renderState.by = this.physics.by;
                this.renderState.scoreL = this.physics.scoreL;
                this.renderState.scoreR = this.physics.scoreR;
            }

            updateOnline(dt) {
                const now = Date.now();

                if (this.state.role === 'host') {
                    // Host: Authoritative physics
                    this.physics.updatePaddle('L', this.inputY);
                    
                    const result = this.physics.update(dt);
                    
                    if (result) {
                        this.physics.freeze();
                        
                        if (this.physics.scoreL >= WIN_SCORE || this.physics.scoreR >= WIN_SCORE) {
                            const winner = "YOU " + (this.physics.scoreL > this.physics.scoreR ? "WIN!" : "LOST!");
                            this.stopGame(winner);
                            if (this.webrtc) {
                                this.webrtc.send({
                                    type: 'gameOver',
                                    winner: this.physics.scoreL > this.physics.scoreR ? 'host' : 'guest'
                                });
                            }
                            return;
                        } else {
                            if (this.webrtc) {
                                this.webrtc.send({
                                    type: 'startCountdown',
                                    direction: result === 'scoreL' ? -1 : 1
                                });
                            }
                            
                            this.startRoundCountdown(() => {
                                this.physics.reset(result === 'scoreL' ? -1 : 1);
                                
                                if (this.webrtc) {
                                    this.webrtc.send({
                                        type: 'ballReset',
                                        bx: this.physics.bx,
                                        by: this.physics.by,
                                        bvx: this.physics.bvx,
                                        bvy: this.physics.bvy
                                    });
                                }
                            });
                        }
                    }

                    // Send state to guest
                    if (now - this.lastNetworkUpdate >= NETWORK_DT && this.webrtc) {
                        const state = this.physics.getState();
                        this.webrtc.send({
                            type: 'state',
                            ...state
                        });
                        this.lastNetworkUpdate = now;
                    }

                    // Update render state
                    this.renderState.pL = this.physics.pL;
                    this.renderState.pR = this.physics.pR;
                    this.renderState.bx = this.physics.bx;
                    this.renderState.by = this.physics.by;
                    this.renderState.scoreL = this.physics.scoreL;
                    this.renderState.scoreR = this.physics.scoreR;

                } else {
                    // Guest: Prediction
                    this.prediction.predict(dt / 1000);
                    
                    // Send paddle position
                    if (now - this.lastNetworkUpdate >= NETWORK_DT && this.webrtc) {
                        this.webrtc.send({
                            type: 'paddle',
                            y: this.inputY
                        });
                        this.lastNetworkUpdate = now;
                    }

                    // Update render state
                    this.renderState.pR = this.inputY;
                    this.renderState.bx = this.prediction.bx;
                    this.renderState.by = this.prediction.by;
                }

                this.updateLatencyDisplay();
            }

            render() {
                // Update paddle positions
                this.gfxL.y = this.renderState.pL;
                this.gfxR.y = this.renderState.pR;

                // Update ball position with trail
                const oldX = this.ball.x;
                const oldY = this.ball.y;
                this.ball.x = this.renderState.bx;
                this.ball.y = this.renderState.by;

                // Draw trail (clear old to prevent memory leak)
                this.ballTrail.clear();
                this.ballTrail.lineStyle(BALL_RADIUS * 1.5, 0xffffff, 0.15);
                this.ballTrail.moveTo(oldX, oldY);
                this.ballTrail.lineTo(this.ball.x, this.ball.y);

                // Update score
                this.updateScoreDisplay();
            }

            async host() {
                this.state.playerName = await this.getPlayerName();
                const btn = document.getElementById('btnHost');
                if(btn.disabled) return;
                btn.disabled = true;
                
                let code, attempts = 0;
                while(attempts < 20) {
                    code = Math.floor(1000 + Math.random() * 9000).toString();
                    try {
                        const exists = await get(ref(db, 'rooms/' + code));
                        if(!exists.exists()) break;
                    } catch(e) { break; }
                    attempts++;
                }
                
                if(attempts >= 20) {
                    this.showError('Failed to create room - too many active rooms');
                    btn.disabled = false;
                    return;
                }

                this.state.room = code;
                this.state.role = 'host';
                
                document.getElementById('lobbyMain').classList.add('hidden');
                document.getElementById('lobbyWait').classList.remove('hidden');
                document.getElementById('codeDisp').innerText = code;

                try {
                    const roomRef = ref(db, 'rooms/' + code);
                    
                    // Create room
                    await set(roomRef, { 
                        host: this.state.playerName,
                        status: 'waiting',
                        created: Date.now()
                    });
                    
                    // Setup disconnect handler
                    this.roomDisconnectRef = onDisconnect(roomRef);
                    await this.roomDisconnectRef.remove();

                    // Initialize WebRTC
                    this.webrtc = new WebRTCManager(
                        true,
                        (data) => this.onWebRTCMessage(data),
                        (status) => this.updateConnectionStatus(status)
                    );
                    
                    await this.webrtc.init(code);

                    // Wait for guest
                    this.guestRef = ref(db, `rooms/${code}/guest`);
                    this.guestListener = onValue(this.guestRef, (snap) => {
                        const guest = snap.val();
                        if (guest && !this.state.playing) {
                            this.state.opponentName = escapeHTML(guest.substring(0, 20));
                            this.startOnlineGame();
                        }
                    });

                } catch(error) {
                    console.error('Host error:', error);
                    this.showError('Failed to create room');
                    this.cancelHosting();
                }
            }

            async join() {
                this.state.playerName = await this.getPlayerName();
                const codeInput = document.getElementById('codeIn');
                const code = codeInput.value.trim();
                const fb = document.getElementById('joinFeedback');
                const btn = document.getElementById('btnJoin');

                if(!code || !/^\d{4}$/.test(code)) {
                    fb.textContent = 'Enter valid 4-digit code';
                    return;
                }

                if(btn.disabled) return;
                btn.disabled = true;
                fb.textContent = 'Connecting...';

                try {
                    const roomRef = ref(db, 'rooms/' + code);
                    const snap = await get(roomRef);

                    if(!snap.exists()) {
                        fb.textContent = 'Room not found';
                        btn.disabled = false;
                        return;
                    }

                    const roomData = snap.val();
                    
                    if(roomData.guest || roomData.status !== 'waiting') {
                        fb.textContent = 'Room is full or in progress';
                        btn.disabled = false;
                        return;
                    }

                    this.state.room = code;
                    this.state.role = 'guest';
                    this.state.opponentName = escapeHTML((roomData.host || 'Host').substring(0, 20));

                    // Join room
                    await update(roomRef, { 
                        guest: this.state.playerName,
                        status: 'playing'
                    });
                    
                    // Setup disconnect handler
                    this.roomDisconnectRef = onDisconnect(roomRef);
                    await this.roomDisconnectRef.remove();

                    // Initialize WebRTC
                    this.webrtc = new WebRTCManager(
                        false,
                        (data) => this.onWebRTCMessage(data),
                        (status) => this.updateConnectionStatus(status)
                    );
                    
                    await this.webrtc.init(code);

                    this.startOnlineGame();

                } catch(error) {
                    console.error('Join error:', error);
                    fb.textContent = 'Connection failed';
                    btn.disabled = false;
                    this.showError('Failed to join');
                }
            }

            startOnlineGame() {
                this.state.mode = 'online';
                this.state.playing = true;
                this.gameStopped = false;
                
                this.physics.scoreL = 0;
                this.physics.scoreR = 0;
                
                if (this.state.role === 'guest') {
                    const state = this.physics.getState();
                    this.prediction.hardSet(state.bx, state.by, state.bvx, state.bvy);
                }
                
                this.updateScoreDisplay();
                this.updatePlayerLabels();
                this.updateConnectionStatus('connecting');
                
                document.getElementById('lobbyScreen').classList.add('hidden');
                document.getElementById('lobbyWait').classList.add('hidden');
                document.getElementById('gameHud').classList.remove('hidden');

                this.startRoundCountdown(() => {
                    if (this.state.role === 'host') {
                        this.physics.reset();
                        if (this.webrtc) {
                            this.webrtc.send({
                                type: 'ballReset',
                                bx: this.physics.bx,
                                by: this.physics.by,
                                bvx: this.physics.bvx,
                                bvy: this.physics.bvy
                            });
                        }
                    } else {
                        this.prediction.activate();
                    }
                });
            }

            onWebRTCMessage(data) {
                if (this.state.role === 'host') {
                    // Host receives paddle position
                    if (data.type === 'paddle') {
                        if (typeof data.y === 'number' && !isNaN(data.y) && isFinite(data.y)) {
                            this.physics.updatePaddle('R', data.y);
                        }
                    }
                } else {
                    // Guest receives game state
                    if (data.type === 'state') {
                        if (typeof data.bx === 'number' && !isNaN(data.bx) && isFinite(data.bx)) {
                            this.prediction.updateTarget(data.bx, data.by, data.bvx, data.bvy, data.timestamp);
                            this.renderState.pL = sanitize(data.pL, PADDLE_MIN_Y, PADDLE_MAX_Y);
                            this.renderState.scoreL = sanitize(data.scoreL, 0, WIN_SCORE);
                            this.renderState.scoreR = sanitize(data.scoreR, 0, WIN_SCORE);
                            this.updateScoreDisplay();
                        }
                    } else if (data.type === 'ballReset') {
                        if (typeof data.bx === 'number' && !isNaN(data.bx) && isFinite(data.bx)) {
                            this.prediction.hardSet(data.bx, data.by, data.bvx, data.bvy);
                            this.prediction.activate();
                        }
                    } else if (data.type === 'startCountdown') {
                        this.prediction.freeze();
                        this.startRoundCountdown(() => {
                            // Wait for ballReset
                        });
                    } else if (data.type === 'gameOver') {
                        const winner = data.winner === 'guest' ? "YOU WIN!" : "YOU LOST!";
                        this.stopGame(winner);
                    }
                }
            }

            showError(message) {
                const errorEl = document.getElementById('connectionError');
                errorEl.textContent = message;
                errorEl.classList.remove('hidden');
                setTimeout(() => errorEl.classList.add('hidden'), 5000);
            }
        }

        // Global error handler
        window.addEventListener('error', (e) => {
            console.error('Fatal error:', e.error);
        });

        window.addEventListener('unhandledrejection', (e) => {
            console.error('Unhandled promise rejection:', e.reason);
        });

        window.addEventListener('load', () => {
            try {
                new PongGame();
            } catch(error) {
                console.error('Fatal:', error);
                alert('Failed to start game. Please refresh.');
            }
        });
    </script>
</body>
</html>
